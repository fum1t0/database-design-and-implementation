# Cp04. Memory Management

この章では、データベースエンジンの2つのコンポーネント、ログマネージャとバッファマネージャについて研究する。それぞれのコンポーネントは特定のファイルを管理する責任がある。ログマネージャはログファイルを管理し、バッファマネージャはデータファイルを管理する。

両コンポーネントは、ディスクブロックの読み書きをメインメモリと効率的に管理する問題に直面している。データベースの内容は通常、メインメモリよりもはるかに大きいため、これらのコンポーネントはブロックをメモリ内外にシャトルする必要があるかもしれない。この章では、それぞれのメモリニーズと使用されるメモリ管理アルゴリズムを検討する。ログマネージャはログファイルへの順次アクセスのみをサポートし、シンプルかつ最適なメモリ管理アルゴリズムを持つ。一方、バッファマネージャはユーザーファイルへの任意のアクセスをサポートしなければならず、これははるかに難しい課題である。

## 4.1 データベースメモリ管理の2つの原則

データベースエンジンがディスク上の値を読み取る唯一の方法は、その値を含むブロックをメモリのページに読み込むことであり、ディスクの値を書き込む唯一の方法は、修正されたページをそのブロックに書き戻すことである。データベースエンジンは、データをディスクとメモリ間で移動する際に、2つの重要な原則に従う。ディスクアクセスを最小限に抑えることと、仮想メモリに依存しないことである。

### 原則1: ディスクアクセスを最小限に抑える

ディスクからデータを読み取り、そのデータを検索し、さまざまな計算を行い、一部の変更を加えてデータを書き戻すアプリケーションを考える。この操作に要する時間をどのように見積もるかを考えてみる。RAMの操作はフラッシュよりも1000倍速く、ディスクよりも100,000倍速い。これは、ほとんどの実際の状況では、ディスクからブロックを読み書きする時間がRAMでそのブロックを処理する時間と少なくとも同じくらい大きいことを意味する。したがって、データベースエンジンができる最も重要なことは、ブロックアクセスを最小限に抑えることである。

ブロックアクセスを最小限に抑える一つの方法は、ディスクブロックへの複数回のアクセスを避けることである。この種の問題は多くの計算領域で発生し、標準的な解決策としてキャッシングが知られている。例えば、CPUは以前に実行された命令のローカルハードウェアキャッシュを持ち、次の命令がキャッシュにあれば、CPUはそれをRAMから読み込む必要がない。また、ブラウザは以前にアクセスしたウェブページのキャッシュを保持し、ユーザーがそのページを要求した場合（例えば、ブラウザの「戻る」ボタンを押した場合）、ブラウザはネットワークからそれを取得する必要がない。

データベースエンジンはメモリページを使用してディスクブロックをキャッシュする。どのページがどのブロックの内容を含んでいるかを追跡することで、エンジンは既存のページを使用してクライアントの要求を満たし、ディスク読み取りを避けることができる。同様に、エンジンは必要なときにのみページを書き込み、ページへの複数の変更を1回のディスク書き込みで処理できるようにする。

ディスクアクセスを最小限に抑える必要性は非常に重要であり、データベースエンジンの実装全体に浸透している。例えば、エンジンが使用する検索アルゴリズムは、ディスクへのアクセスを控えめにする方法で選ばれている。そして、SQLクエリがいくつかの検索戦略を持つ場合、プランナーはディスクアクセスの回数が最も少ないと思われる戦略を選ぶ。

### 原則2: 仮想メモリに依存しない

現代のオペレーティングシステムは仮想メモリをサポートしている。オペレーティングシステムは各プロセスに対して、コードとデータを格納するための非常に大きなメモリを持っているという錯覚を与える。プロセスは仮想メモリ空間内で任意にオブジェクトを割り当てることができ、オペレーティングシステムは各仮想ページを物理メモリの実際のページにマップする。

オペレーティングシステムがサポートする仮想メモリ空間は通常、コンピュータの物理メモリよりもはるかに大きい。すべての仮想ページが物理メモリに収まらないため、OSはそれらの一部をディスクに保存する必要がある。プロセスがメモリにない仮想ページにアクセスすると、ページスワップが発生する。OSは物理ページを選択し、そのページの内容をディスクに書き込み（修正されている場合）、ディスクからそのページに仮想ページの保存内容を読み込む。

データベースエンジンがディスクブロックを管理する最も単純な方法は、各ブロックにそれ自身の仮想ページを割り当てることである。例えば、ファイルごとにページの配列を保持し、ファイルの各ブロックに1つのスロットを持つ。この配列は非常に大きくなるが、仮想メモリに収まる。データベースシステムがこれらのページにアクセスすると、仮想メモリ機構がそれらをディスクと物理メモリの間でスワップする。これはシンプルで実装が容易な戦略である。しかし、重大な問題がある。それは、ページがディスクに書き込まれるタイミングを制御するのがオペレーティングシステムであり、データベースエンジンではないということである。2つの問題が生じる。

第一の問題は、オペレーティングシステムのページスワッピング戦略がシステムクラッシュ後のデータベースエンジンのリカバリ能力を損なう可能性があることである。その理由は、修正されたページには関連するログレコードがあり、これらのログレコードはページよりも先にディスクに書き込まれなければならないためである（そうでなければ、システムクラッシュ後のリカバリにログレコードを使用できなくなる）。OSはログについて知らないため、修正されたページをログレコードを書き込まずにスワップアウトし、リカバリ機構を妨げる可能性がある。

第二の問題は、オペレーティングシステムが現在使用されているページと、データベースエンジンがもう気にしないページを把握していないことである。OSは最近アクセスされていないページを選択するなど、推測に基づいてスワップを行う。しかし、OSが間違った推測をすると、再度必要となるページをスワップアウトし、不要なディスクアクセスが2回発生する。データベースエンジンはどのページが必要かをはるかに把握しており、より賢明な推測ができる。

したがって、データベースエンジンは独自のページを管理する必要がある。エンジンは物理メモリに収まるとわかっている比較的小さい数のページを割り当てる。これらのページはデータベースのバッファプールと呼ばれる。エンジンはスワップ可能なページを追跡する。ブロックをページに読み込む必要がある場合、データベースエンジン（オペレーティングシステムではなく）がバッファプールから使用可能なページを選び、その内容（およびそのログレコード）を必要に応じてディスクに書き込み、指定されたブロックを読み込む。

## 4.2 ログ情報の管理

ユーザーがデータベースを変更するたびに、その変更を追跡する必要がある。これは、必要に応じて変更を元に戻せるようにするためである。変更を記述する値はログレコードに保持され、ログファイルに保存される。新しいログレコードはログの末尾に追加される。

ログマネージャはログレコードをログファイルに書き込む責任を持つデータベースエンジンのコンポーネントである。ログマネージャはログレコードの内容を理解していない。その責任は第5章のリカバリマネージャにある。代わりに、ログマネージャはログを常に増加するログレコードのシーケンスとして扱う。

このセクションでは、ログマネージャがログレコードをログファイルに書き込む際にメモリをどのように管理できるかを検討する。以下のアルゴリズムを考えてみよう。これはログにレコードを追加する最も簡単な方法である。

1. メモリにページを割り当てる。
2. ログファイルの最後のブロックをそのページに読み込む。
3. 余裕がある場合は、他のレコードの後にログレコードを配置し、ページをディスクに書き戻す。余裕がない場合は、新しい空のページを割り当て、そのページにログレコードを配置し、ログファイルの末尾に新しいブロックとしてページを追加する。

このアルゴリズムでは、追加されるログレコードごとにディスク読み取りとディスク書き込みが必要である。これはシンプルだが非常に非効率的である。図4.2は、アルゴリズムのステップ3aの途中でのログマネージャの操作を示している。ログファイルには、r1からr8までの8つのレコードを保持する3つのブロックが含まれている。ログレコードのサイズは異なるため、ブロック0には4つのレコードが収まり、ブロック1には3つしか収まらない。ブロック2はまだ完全には埋まっておらず、1つのレコードだけが含まれている。メモリページにはブロック2の内容が含まれている。レコードr8に加えて、新しいログレコード（レコードr9）がページに配置されている。

ここで、ログマネージャがページをファイルのブロック2に書き戻してアルゴリズムを完了させるとする。ログマネージャが次にファイルに別のログレコードを追加するよう求められると、アルゴリズムのステップ1と2を実行してブロック2をページに読み込む。しかし、このディスク読み取りは完全に不要である。なぜなら、既存のログページがすでにブロック2の内容を含んでいるからである。したがって、アルゴリズムのステップ1と2は不要である。ログマネージャは、最後のログブロックの内容を含むページを永久に割り当てるだけでよい。この結果、すべてのディスク読み取りが排除される。

また、ディスク書き込みを減らすことも可能である。上記のアルゴリズムでは、ログマネージャは新しいレコードがページに追加されるたびにページをディスクに書き込む。しかし、図4.2を見れば、レコードr9をすぐにディスクに書き込む必要はないことがわかる。ページに余裕がある限り、新しいログレコードはページに追加されるだけでよい。ページがいっぱいになったとき、ログマネージャはページをディスクに書き込み、その内容をクリアして新たに開始できる。この新しいアルゴリズムでは、各ログブロックごとに正確に1回のディスク書き込みが必要となり、明らかに最適である。

このアルゴリズムには一つの欠点がある。ログページは、ログマネージャの制御を超えた状況によって、満杯になる前にディスクに書き込まれる必要がある場合がある。この問題は、バッファマネージャが関連するログレコードがディスクに書き込まれるまで、修正されたデータページをディスクに書き込むことができないことである。これらのログレコードの一つがログページにあり、まだディスクに書き込まれていない場合、ログマネージャはページが満杯であるかどうかに関係なく、そのページをディスクに書き込む必要がある。この問題は第5章で対処する。

以下に最終的なログ管理アルゴリズムが示されている。このアルゴリズムには、メモリページがディスクに書き込まれる2つの場所がある。ログレコードをディスクに強制的に書き込む必要がある場合と、ページが満杯になった場合である。したがって、メモリページは同じログブロックに複数回書き込まれる可能性がある。しかし、これらのディスク書き込みは絶対に必要であり避けられないため、このアルゴリズムは最適であると結論付けられる。

1. ログファイルの最後のブロックの内容を保持するために1つのメモリページを永久に割り当てる。このページをPと呼ぶ。
2. 新しいログレコードが提出されたとき：  
   1. Pに余裕がない場合：  
      Pをディスクに書き込み、その内容をクリアする。
   2. 新しいログレコードをPに追加する。
3. データベースシステムが特定のログレコードをディスクに書き込むよう要求した場合：
   1. そのログレコードがPにあるかどうかを判断する。
   2. もしそうなら、Pをディスクに書き込む。

## 4.3 SimpleDBログマネージャ

このセクションでは、SimpleDBデータベースシステムのログマネージャを検討する。セクション4.3.1ではログマネージャの使用例を示し、セクション4.3.2ではその実装を検討する。

### 4.3.1 ログマネージャのAPI

SimpleDBのログマネージャの実装は、`simpledb.log`パッケージに含まれている。このパッケージは`LogMgr`クラスを公開しており、そのAPIは以下に示されている。

```java
// LogMgr
public LogMgr(FileMgr fm, String logfile);
public int  append(byte[] rec);
public void flush(int lsn);
public Iterator<byte[]> iterator();
```

データベースエンジンには`LogMgr`オブジェクトが1つあり、システム起動時に作成される。コンストラクタの引数はファイルマネージャへの参照とログファイルの名前である。

`append`メソッドはレコードをログに追加し、整数を返す。ログマネージャにとって、ログレコードは任意のサイズのバイト配列であり、ログファイルに配列を保存するが、その内容が何を意味するかは理解しない。唯一の制約は、配列がページ内に収まることである。`append`の戻り値は新しいログレコードを識別し、この識別子をログシーケンス番号（LSN）と呼ぶ。

ログにレコードを追加することは、そのレコードがディスクに書き込まれることを保証しない。代わりに、ログマネージャは先程のアルゴリズムに従ってログレコードをディスクに書き込むタイミングを選択する。クライアントは`flush`メソッドを呼び出すことで特定のログレコードをディスクに強制的に書き込むことができる。`flush`の引数はログレコードのLSNであり、このメソッドはそのログレコード（およびそれ以前のすべてのログレコード）がディスクに書き込まれることを保証する。

クライアントは`iterator`メソッドを呼び出してログのレコードを読み取る。このメソッドはログレコードのJavaイテレータを返す。イテレータの`next`メソッドを呼び出すと、ログの次のレコードを示すバイト配列が返される。`iterator`メソッドによって返されるレコードは逆順であり、最新のレコードから始まりログファイルを逆向きに進む。この順序でレコードが返されるのは、リカバリマネージャがその順序でレコードを見たいからである。

以下の`LogTest`クラスは、ログマネージャAPIの使用例を提供している。このコードは、文字列と整数からなる70のログレコードを作成する。整数はレコード番号Nであり、文字列は「recordN」という値である。このコードは、最初の35レコードが作成された後と、70レコードすべてが作成された後にレコードを出力する。

```java
public class LogTest {
  private static LogMgr lm;

  public static void main(String[] args) {
    SimpleDB db = new SimpleDB("logtest", 400, 8);
    lm = db.logMgr();
    createRecords(1, 35);
    printLogRecords("The log file now has these records:");
    createRecords(36, 70);
    lm.flush(65);
    printLogRecords("The log file now has these records:");
  }

  private static void printLogRecords(String msg) {
    System.out.println(msg);
    Iterator<byte[]> iter = lm.iterator();
    while (iter.hasNext()) {
      byte[] rec = iter.next();
      Page p = new Page(rec);
      String s = p.getString(0);
      int npos = Page.maxLength(s.length());
      int val = p.getInt(npos);
      System.out.println("[" + s + ", " + val + "]");
    }
    System.out.println();
  }

  private static void createRecords(int start, int end) {
    System.out.print("Creating records: ");
    for (int i=start; i<=end; i++) {
      byte[] rec = createLogRecord("record"+i, i+100);
      int lsn = lm.append(rec);
      System.out.print(lsn + " ");
    }
    System.out.println();
  }

  private static byte[] createLogRecord(String s, int n) {
    int npos = Page.maxLength(s.length());
    byte[] b = new byte[npos + Integer.BYTES];
    Page p = new Page(b);
    p.setString(0, s);
    p.setInt(npos, n);
    return b;
  }
}
```

このコードを実行すると、最初の`printLogRecords`呼び出しの後に20レコードしか出力されないことがわかる。これは、そのレコードが最初のログブロックを埋め、21番目のログレコードが作成されたときにディスクにフラッシュされたためである。他の15のログレコードはメモリ内のログページに残り、フラッシュされなかった。2回目の`createRecords`呼び出しは、36から70までのレコードを作成する。`flush`の呼び出しは、ログマネージャに65番目のレコードがディスクにあることを確認するよう指示する。しかし、レコード66〜70は65番目のレコードと同じページにあるため、それらもディスクに書き込まれる。したがって、2回目の`printLogRecords`呼び出しは、逆順で全ての70レコードを出力することになる。

`createLogRecord`メソッドがバイト配列をログレコードとして割り当てる方法に注目する。このメソッドは、その配列をラップする`Page`オブジェクトを作成し、ページの`setInt`と`setString`メソッドを使用して、ログレコードの適切なオフセットに文字列と整数を配置する。その後、コードはバイト配列を返す。同様に、`printLogRecords`メソッドはログレコードをラップする`Page`オブジェクトを作成し、レコードから文字列と整数を抽出する。

## 4.3.2 ログマネージャの実装

`LogMgr`のコードは以下に示されている。コンストラクタは、指定された文字列をログファイルの名前として使用する。ログファイルが空の場合、コンストラクタは新しい空のブロックを追加する。また、コンストラクタは1つのページ（logpageと呼ばれる）を割り当て、ファイル内の最後のログブロックの内容を含むように初期化する。

```java
public class LogMgr {
  private FileMgr fm;
  private String logfile;
  private Page logpage;
  private BlockId currentblk;
  private int latestLSN = 0;
  private int lastSavedLSN = 0;

  public LogMgr(FileMgr fm, String logfile) {
    this.fm = fm;
    this.logfile = logfile;
    byte[] b = new byte[fm.blockSize()];
    logpage = new Page(b);
    int logsize = fm.length(logfile);
    if (logsize == 0) {
      currentblk = appendNewBlock();
    } else {
      currentblk = new BlockId(logfile, logsize-1);
      fm.read(currentblk, logpage);
    }
  }

  public void flush(int lsn) {
    if (lsn >= lastSavedLSN) flush();
  }

  public Iterator<byte[]> iterator() {
    flush();
    return new LogIterator(fm, currentblk);
  }

  public synchronized int append(byte[] logrec) {
    int boundary = logpage.getInt(0);
    int recsize = logrec.length;
    int bytesneeded = recsize + Integer.BYTES;
    if (boundary - bytesneeded < Integer.BYTES){ // It doesn't fit
      flush(); // so move to the next block.
      currentblk = appendNewBlock();
      boundary = logpage.getInt(0);
    }
    int recpos = boundary - bytesneeded;
    logpage.setBytes(recpos, logrec);
    logpage.setInt(0, recpos); // the new boundary
    return ++latestLSN;
  }
  
  private BlockId appendNewBlock() {
    BlockId blk = fm.append(logfile);
    logpage.setInt(0, fm.blockSize());
    fm.write(blk, logpage);
    return blk;
  }
  
  private void flush() {
    fm.write(currentblk, logpage);
    lastSavedLSN = latestLSN;
  }
}
```

ログシーケンス番号（LSN）はログレコードを識別するものであることを思い出してほしい。`append`メソッドは`latestLSN`変数を使用して、LSNを1から順に割り当てる。ログマネージャは次に利用可能なLSNと、ディスクに書き込まれた最新のログレコードのLSNを追跡する。`flush`メソッドは、最新のLSNと指定されたLSNを比較する。指定されたLSNが小さい場合、目的のログレコードはすでにディスクに書き込まれているはずである。そうでない場合は、logpageがディスクに書き込まれ、最新のLSNが最も新しいものとなる。

`append`メソッドはログレコードのサイズを計算し、それが現在のページに収まるかどうかを確認する。収まらない場合、現在のページをディスクに書き込み、`appendNewBlock`を呼び出してページをクリアし、空のページをログファイルに追加する。この戦略は図4.3のアルゴリズムとは少し異なる。具体的には、ログマネージャはファイルに全てのページを追加することで拡張するのではなく、空のページを追加することでログファイルを拡張する。この戦略は、ブロックがすでにディスク上にあると仮定できるため、`flush`の実装を簡素化する。

`append`はログレコードを右から左にページに配置する。変数`boundary`は、最も最近追加されたレコードのオフセットを含む。この戦略により、ログイテレータは左から右に読み取ることでレコードを逆順に読むことができる。`boundary`の値はページの最初の4バイトに書き込まれ、イテレータがレコードの開始位置を知ることができる。

`iterator`メソッドはログをフラッシュして（ログ全体がディスク上にあることを確認するため）、`LogIterator`オブジェクトを返す。クラス`LogIterator`はパッケージプライベートクラスであり、イテレータを実装している。そのコードは以下に示されている。`LogIterator`オブジェクトはログブロックの内容を保持するページを割り当てる。コンストラクタはイテレータをログの最後のブロックの最初のレコードに位置させる（これは、最後のログレコードが書き込まれた場所であることを思い出してほしい）。`next`メソッドはページ内の次のレコードに移動する。レコードがなくなると、前のブロックをページに読み込み、その最初のレコードを返す。`hasNext`メソッドは、ページ内にレコードがなく、前のブロックもない場合に`false`を返す。

```java
class LogIterator implements Iterator<byte[]> {
  private FileMgr fm;
  private BlockId blk;
  private Page p;
  private int currentpos;
  private int boundary;

  public LogIterator(FileMgr fm, BlockId blk) {
    this.fm = fm;
    this.blk = blk;
    byte[] b = new byte[fm.blockSize()];
    p = new Page(b);
    moveToBlock(blk);
  }

  public boolean hasNext() {
    return currentpos<fm.blockSize() || blk.number()>0;
  }

  public byte[] next() {
    if (currentpos == fm.blockSize()) {
      blk = new BlockId(blk.fileName(), blk.number()-1);
      moveToBlock(blk);
    }
    byte[] rec = p.getBytes(currentpos);
    currentpos += Integer.BYTES + rec.length;
    return rec;
  }

  private void moveToBlock(BlockId blk) {
    fm.read(blk, p);
    boundary = p.getInt(0);
    currentpos = boundary;
  }
}
```

## 4.4 ユーザーデータの管理

ログレコードは限定的でよく理解された方法で使用される。したがって、ログマネージャはメモリの使用を微調整することができ、特に専用の1ページで最適に動作する。同様に、各LogIteratorオブジェクトも1ページだけを必要とする。

一方、JDBCアプリケーションは完全に予測不可能な方法でデータにアクセスする。アプリケーションが次にどのブロックを要求するか、またそのブロックを再びアクセスするかどうかを知る方法はない。そして、アプリケーションがブロックの使用を完全に終了した後でも、他のアプリケーションが近い将来にそれらのブロックのいずれかにアクセスするかどうかを知ることはできない。このセクションでは、このような状況でデータベースエンジンがどのように効率的にメモリを管理できるかを説明する。

### 4.4.1 バッファマネージャ

バッファマネージャは、ユーザーデータを保持するページを管理するデータベースエンジンのコンポーネントである。バッファマネージャは、バッファプールと呼ばれる固定されたページセットを割り当てる。冒頭で述べたように、バッファプールはコンピュータの物理メモリに収まるべきであり、これらのページはオペレーティングシステムが保持するI/Oバッファから供給されるべきである。

ブロックにアクセスするために、クライアントは以下に示されるプロトコルに従ってバッファマネージャとやり取りする。ページは、あるクライアントが現在それをピン留めしている場合にピン留めされていると言い、それ以外の場合はピン留めされていないと言う。バッファマネージャは、ページがピン留めされている限り、そのページをクライアントに提供し続ける義務がある。逆に、ページがピン留めされなくなった場合、バッファマネージャはそのページを別のブロックに割り当てることができる。

1. クライアントはバッファプールからそのブロックにページをピン留めするようバッファマネージャに依頼する。
2. クライアントはページの内容に好きなだけアクセスする。
3. クライアントがページの使用を終えたら、バッファマネージャにページのピン留めを解除するよう通知する。

クライアントがバッファマネージャにページをブロックにピン留めするよう依頼したとき、バッファマネージャは次の4つの可能性に直面する。

- ブロックの内容がバッファ内のあるページに存在し、そのページが：
  - ピン留めされている。
  - ピン留めされていない。

- ブロックの内容が現在どのバッファにも存在せず、次の状態：
  - バッファプールに少なくとも1つのピン留めされていないページが存在する。
  - バッファプール内のすべてのページがピン留めされている。

最初のケースは、1つ以上のクライアントが現在ブロックの内容にアクセスしている場合に発生する。ページは複数のクライアントによってピン留めされる可能性があるため、バッファマネージャはページに別のピンを追加し、そのページをクライアントに返す。ページをピン留めしている各クライアントは、その値を同時に読み取りおよび変更することができる。バッファマネージャは、発生する可能性のある競合については気にせず、その責任は第5章の同時実行マネージャにある。

第2のケースは、バッファを使用していたクライアントが使用を終了したが、バッファがまだ再割り当てされていない場合に発生する。ブロックの内容がまだバッファページにあるため、バッファマネージャは単にそのページを再利用してピン留めし、クライアントに返すことができる。

第3のケースでは、バッファマネージャがディスクからブロックをバッファページに読み込む必要がある。いくつかのステップが含まれる。まず、バッファマネージャは再利用するためのピン留めされていないページを選択しなければならない（ピン留めされているページはクライアントによってまだ使用されているため）。次に、選択されたページが変更されている場合、バッファマネージャはそのページの内容をディスクに書き込まなければならない。このアクションはページをフラッシュするという。最後に、要求されたブロックを選択されたページに読み込み、そのページをピン留めすることができる。

第4のケースは、第14章のクエリ処理アルゴリズムのように、バッファが非常に多く使用されている場合に発生する。この場合、バッファマネージャはクライアントの要求を満たすことができない。最善の解決策は、バッファマネージャがクライアントを待機リストに配置し、ピン留めされていないバッファページが利用可能になるまで待機させることである。

### 4.4.2 バッファ

バッファプール内の各ページには、ピン留めされているかどうか、またピン留めされている場合はどのブロックに割り当てられているかなどのステータス情報が関連付けられている。バッファはこの情報を含むオブジェクトである。バッファプール内の各ページには対応するバッファがある。各バッファはそのページの変更を監視し、変更されたページをディスクに書き込む責任がある。ログと同様に、バッファはページの書き込みを遅延させることでディスクアクセスを削減できる。例えば、ページが複数回変更された場合、すべての変更が行われた後にページを1回書き込む方が効率的である。合理的な戦略は、ページがピン留め解除されるまでバッファがページのディスクへの書き込みを延期することである。

実際には、バッファはさらに長く待つこともできる。例えば、変更されたページがピン留め解除されてもディスクに書き込まれない場合を考える。このページが再び同じブロックにピン留めされる場合（上記の第2のケースのように）、クライアントは変更された内容をそのまま見ることができる。これは、ページがディスクに書き込まれ、その後読み戻されたのと同じ効果を持つが、ディスクアクセスは発生しない。ある意味で、バッファのページはそのディスクブロックのインメモリバージョンとして機能する。ブロックを使用したいクライアントは、単にバッファページに誘導され、そのクライアントはディスクアクセスなしで読み取りや変更を行うことができる。

実際には、バッファが変更されたページをディスクに書き込む必要があるのは、次の2つの理由だけである。ページが異なるブロックにピン留めされるために置き換えられている場合（上記の第3のケースのように）、またはシステムクラッシュに備えてリカバリマネージャがその内容をディスクに書き込む必要がある場合（第5章で説明する）。

## 4.4.3 バッファ置換戦略

バッファプール内のページは初めは未割り当てである。ピン要求が到着するにつれて、バッファマネージャは要求されたブロックを未割り当てのページに割り当てることでバッファプールを初期化する。すべてのページが割り当てられると、バッファマネージャはページの置換を開始する。バッファマネージャはバッファプール内のピンされていないページを置換のために選ぶことができる。

バッファマネージャがページを置換する必要があるとき、すべてのバッファページがピンされている場合、要求しているクライアントは待たなければならない。したがって、各クライアントは「良き市民」として、ページが不要になったらすぐにピンを外す責任がある。

複数のバッファページがピン解除されたとき、バッファマネージャはどれを置換するかを決めなければならない。この選択はデータベースシステムの効率に劇的な影響を与える可能性がある。例えば、最悪の選択は次にアクセスされるページを置換することであり、その場合バッファマネージャはすぐに別のページを置換しなければならなくなる。最良の選択は、最も長い間使用されないページを常に置換することである。

バッファマネージャはどのページが次にアクセスされるか予測できないため、推測するしかない。ここで、バッファマネージャは仮想メモリでページをスワップするオペレーティングシステムとほぼ同じ状況にある。しかし、大きな違いが1つある。オペレーティングシステムとは異なり、バッファマネージャはページが現在使用中かどうかを知っている。なぜなら、使用中のページはピンされているページだからである。ピンされているページを置換できないという負担は実際には祝福である。クライアントが責任を持ってページをピンすることで、バッファマネージャが本当に悪い推測をするのを防ぐ。バッファ置換戦略は、現在不要なページの中から選ぶだけで済むため、これはあまり重要ではない。

ピン解除されたページのセットを考えると、バッファマネージャはこれらのページの中で最も長い間必要とされないページを選ぶ必要がある。例えば、データベースには通常、データベースの存続期間中ずっと使用されるページ（第7章のカタログファイルなど）がいくつかある。バッファマネージャはそのようなページを置換しないようにすべきであり、そうでなければすぐに再ピンされる可能性が高い。いくつかの置換戦略が最善の推測を試みる。このセクションでは、4つの戦略を考察する：ナイーブ、FIFO、LRU、およびクロック。

図4.9は、これらの置換アルゴリズムの動作を比較するための例を示している。パート(a)は5つのファイルブロックをピンおよびアンピンする一連の操作を示し、パート(b)はバッファプールの結果状態を示している。この時点では、ページ置換は5番目のブロック（すなわちブロック50）がピンされたときにのみ発生した。しかし、その時点ではバッファが1つだけピン解除されていたため、バッファマネージャには選択の余地がなかった。つまり、バッファプールはページ置換戦略に関係なく図4.9bのようになる。

図4.9bの各バッファは、ブロック番号、バッファに読み込まれた時間、およびピン解除された時間という3つの情報を保持している。図の時間は図4.9aの操作の位置に対応している。

図4.9bのバッファはすべてピン解除されている。ここでバッファマネージャが2つのピン要求を受け取ると仮定する：

pin(60); pin(70);

バッファマネージャは2つのバッファを置換する必要がある。すべてのバッファが利用可能である。どれを選ぶべきか？以下の置換アルゴリズムはそれぞれ異なる答えを出す。

### ナイーブ戦略

最も単純な置換戦略は、バッファプールを順番に走査し、最初に見つかったピン解除されたバッファを置換することである。図4.9の例を使用すると、ブロック60はバッファ0に割り当てられ、ブロック70はバッファ1に割り当てられる。

この戦略は実装が容易であるが、それ以外に推奨する理由はほとんどない。例えば、再び図4.9のバッファを考え、クライアントが次のようにブロック60と70を繰り返しピンおよびアンピンすると仮定する：

pin(60); unpin(60); pin(70); unpin(70); pin(60); unpin(60);...

ナイーブ置換戦略は両方のブロックに対してバッファ0を使用するため、ブロックはピンされるたびにディスクから読み込む必要がある。問題はバッファプールが均等に利用されていないことである。置換戦略がブロック60と70に対して異なる2つのバッファを選んでいた場合、ブロックはそれぞれ1回ずつディスクから読み込まれるだけで済み、効率が大幅に向上する。

### FIFO戦略

ナイーブ戦略は便宜的にバッファを選ぶだけである。FIFO戦略は、バッファプールに最も長く存在しているページ、すなわち最も最近置換されていないページを選ぶことで、より賢く選ぼうとする。この戦略は通常、ナイーブ戦略よりもうまく機能する。なぜなら、古いページは最近取得されたページよりも必要とされる可能性が低いためである。図4.9では、最も古いページは「読み込み時間」が最も小さいものである。したがって、ブロック60はバッファ0に、ブロック70はバッファ2に割り当てられる。

FIFOは合理的な戦略であるが、常に正しい選択をするわけではない。例えば、データベースには頻繁に使用されるページ（第7章のカタログページなど）がよくある。これらのページはほぼすべてのクライアントによって使用されるため、可能であれば置換しない方が良い。しかし、これらのページは最終的にプール内で最も古いページになるため、FIFO戦略ではこれらのページを置換することになる。

FIFO置換戦略は2つの方法で実装できる。1つの方法は、各バッファにそのページが最後に置換された時間を保持させる方法であり、図4.9bのようにする。置換アルゴリズムはバッファプールを走査し、最も早い置換時間を持つピン解除されたページを選ぶ。もう1つの、より効率的な方法は、バッファマネージャが置換時間で順序付けられたバッファへのポインタのリストを保持する方法である。置換アルゴリズムはリストを検索し、最初に見つかったピン解除されたページを置換し、そのポインタをリストの末尾に移動する。

### LRU戦略

FIFO戦略は、ページがバッファプールに追加された時間に基づいて置換を決定する。同様の戦略として、ページが最後にアクセスされた時間に基づいて決定する方法がある。この戦略は、最近使用されていないページは近い将来も使用されないという理論に基づいている。この戦略は

LRU（Least Recently Used、最も最近使われていない）と呼ばれる。図4.9の例では、「ピン解除時間」の値がバッファが最後に使用された時間に対応している。したがって、ブロック60はバッファ3に、ブロック70はバッファ0に割り当てられる。

LRU戦略は一般的に効果的な汎用戦略であり、よく使用されるページの置換を避ける。FIFOの2つの実装オプションはどちらもLRUに適応できる。唯一の変更は、バッファマネージャがページが置換されたときではなく、ピン解除されたときにタイムスタンプ（最初のオプション）やリスト（2番目のオプション）を更新することである。

### クロック戦略

この戦略は上記の戦略の興味深い組み合わせであり、簡単かつ直感的な実装が可能である。ナイーブ戦略と同様に、クロック置換アルゴリズムはバッファプールを走査し、最初に見つかったピン解除されたページを選ぶ。違いは、アルゴリズムが常に前回の置換後のページからスキャンを開始する点である。バッファプールを円形に視覚化すると、置換アルゴリズムはアナログ時計の針のようにプールを走査し、ページを置換する際に停止し、次の置換が必要なときに再び開始する。

図4.9bの例では、クロック位置は示されていない。しかし、最後の置換がバッファ1で行われたため、クロックはその直後に位置している。したがって、ブロック60はバッファ2に、ブロック70はバッファ3に割り当てられる。

クロック戦略はバッファをできるだけ均等に利用しようとする。ページがピンされている場合、クロック戦略はそれをスキップし、プール内の他のすべてのバッファを検査するまで再び考慮しない。この機能により、戦略はLRUの要素を持つ。頻繁に使用されるページは、置換の順番が来たときにピンされる可能性が高いため、スキップされて「もう一度チャンス」を得ることになる。

## 4.5 SimpleDBのバッファマネージャ

このセクションでは、SimpleDBデータベースシステムのバッファマネージャについて考察する。セクション4.5.1では、バッファマネージャのAPIを説明し、その使用例を示す。次に、セクション4.5.2では、これらのクラスをJavaで実装する方法を示す。

### 4.5.1 バッファマネージャのAPI

SimpleDBのバッファマネージャは、`simpledb.buffer`パッケージで実装されている。このパッケージには、`BufferMgr`クラスと`Buffer`クラスがあり、そのAPIが以下に示されている。

```java
// BufferMgr
public BufferMgr(FileMgr fm, LogMgr lm, int numbuffs);
public Buffer pin(BlockId blk);
public void   unpin(Buffer buff);
public int    available();
public void   flushAll(int txnum);

// Buffer
public Buffer(FileMgr fm, LogMgr lm);
public Page    contents();
public BlockId block();
public boolean isPinned();
public void    setModified(int txnum, int lsn);
public int     modifyingTx();
```

各データベースシステムには1つの`BufferMgr`オブジェクトがあり、システムの起動時に作成される。コンストラクタには、バッファプールのサイズ、ファイルマネージャ、およびログマネージャへの参照の3つの引数がある。

`BufferMgr`オブジェクトには、ページをピンおよびアンピンするためのメソッドがある。`pin`メソッドは指定されたブロックを含むページにピンされた`Buffer`オブジェクトを返し、`unpin`メソッドはそのページのピンを外す。`available`メソッドはアンピンされたバッファページの数を返し、`flushAll`メソッドは指定されたトランザクションによって変更されたすべてのページがディスクに書き込まれることを保証する。

`Buffer`オブジェクトが与えられると、クライアントはその`contents`メソッドを呼び出して関連するページを取得できる。クライアントがページを変更した場合、適切なログレコードを生成し、バッファの`setModified`メソッドを呼び出す責任も負う。

このメソッドには、変更を行ったトランザクションを識別する整数と、生成されたログレコードのLSNの2つの引数がある。

以下のコードは、`Buffer`クラスをテストするものである。これを最初に実行すると「The new value is 1」と表示され、その後の実行では表示される値が1ずつ増加する。このコードは次のように動作する。3つのバッファを持つ`SimpleDB`オブジェクトを作成し、ブロック1にページをピンし、オフセット80の整数をインクリメントし、そのページが変更されたことを示すために`setModified`を呼び出す。`setModified`への引数はトランザクション番号と生成されたログファイルのLSNである。これら2つの値の詳細は第5章で説明するので、それまでは与えられた引数が妥当なプレースホルダーである。

```java
public class BufferTest {
  public static void main(String[] args) {
    SimpleDB db = new SimpleDB("buffertest", 400, 3);
    BufferMgr bm = db.bufferMgr();

    Buffer buff1 = bm.pin(new BlockId("testfile", 1));
    Page p = buff1.contents();
    int n = p.getInt(80);
    p.setInt(80, n+1); // This modification will
    buff1.setModified(1, 0); // get written to disk.
    System.out.println("The new value is " + (n+1));
    bm.unpin(buff1);
    // One of these pins will flush buff1 to disk:
    Buffer buff2 = bm.pin(new BlockId("testfile", 2));
    Buffer buff3 = bm.pin(new BlockId("testfile", 3));
    Buffer buff4 = bm.pin(new BlockId("testfile", 4));
    
    bm.unpin(buff2);
    buff2 = bm.pin(new BlockId("testfile", 1));
    Page p2 = buff2.contents();
    p2.setInt(80, 9999);  // This modification
    buff2.setModified(1, 0);  // won't get written to disk
    bm.unpin(buff2);
  }
}
```

バッファマネージャは実際のディスクアクセスをクライアントから隠す。クライアントは、自分のために正確に何回のディスクアクセスが発生するか、またそれがいつ発生するかを全く知らない。ディスク読み取りは、指定されたブロックが現在バッファにない場合に、`pin`の呼び出し中にのみ発生する。ディスク書き込みは`pin`または`flushAll`の呼び出し中にのみ発生する。置換されたページが変更された場合、`pin`の呼び出しがディスク書き込みを引き起こし、指定されたトランザクションによって変更された各ページについて、`flushAll`の呼び出しがディスク書き込みを引き起こす。

例えば、先程のコードにはブロック1に対する2つの変更が含まれている。これらの変更はどちらも明示的にディスクに書き込まれない。コードの実行結果は、最初の変更がディスクに書き込まれるが、2番目の変更は書き込まれないことを示している。最初の変更を考えると、バッファプールには3つのバッファしかないため、バッファマネージャはブロック1のページを置換してブロック2、3、および4のページをピンする必要がある。対照的に、2回目の変更後にブロック1のページを置換する必要はないため、ページはディスクに書き込まれず、その変更は失われる。この失われた変更の問題は第5章で議論する。

データベースエンジンに多数のクライアントがいて、多くのバッファを使用していると仮定する。すべてのバッファページがピンされることがあり得る。この場合、バッファマネージャはピン要求を直ちに満たすことができない。代わりに、クライアントを待機リストに追加する。バッファが利用可能になると、バッファマネージャはクライアントを待機リストから外し、ピン要求を完了させる。つまり、クライアントはバッファの競合に気付かず、エンジンが遅くなったと感じるだけである。

バッファの競合が重大な問題を引き起こす状況が1つある。クライアントAとBがそれぞれ2つのバッファを必要としているが、利用可能なバッファが2つしかないシナリオを考える。クライアントAが最初のバッファをピンしたとする。次に2つ目のバッファをめぐって競争が始まる。クライアントAがクライアントBよりも先にそれを取得すれば、Bは待機リストに追加される。クライアントAは最終的に終了してバッファのピンを外し、その時点でクライアントBがそれらをピンできる。これは良いシナリオである。今度はクライアントBがクライアントAより先に2つ目のバッファを取得した場合を考える。するとAとBの両方が待機リストに入る。このシステムにAとBのクライアントしかいない場合、バッファがピン解除されることはなく、両方とも永遠に待機リストに留まる。これは悪いシナリオである。クライアントAとBがデッドロック状態にあると言う。

何千ものバッファと何百ものクライアントを持つ実際のデータベースシステムでは、この種のデッドロックは非常に稀である。それにもかかわらず、バッファマネージャはこの可能性に対処する準備をしておく必要がある。SimpleDBが採用した解決策は、クライアントがバッファを待っている時間を追跡することである。もしクライアントが長すぎる時間（例えば10秒）待っていると、バッファマネージャはクライアントがデッドロックに陥っていると仮定し、`BufferAbortException`という型の例外をスローする。クライアントは例外を処理する責任があり、通常はトランザクションをロールバックし、再試行することになる。

以下のコードはバッファマネージャをテストするものである。再び3つのバッファしか持たない`SimpleDB`オブジェクトを作成し、バッファマネージャに対してファイル「testfile」のブロック0、1、および2にページをピンするように呼び出す。その後、ブロック1のピンを外し、ブロック2を再度ピンし、再びブロック1をピンする。これらの3つの操作はディスク読み取りを引き起こさず、利用可能なバッファは残らない。ブロック3をピンしようとすると、スレッドが待機リストに追加される。しかし、スレッドはすでにすべてのバッファを保持しているため、どれもピン解除されず、バッファマネージャは10秒の待機後に例外をスローする。プログラムは例外をキャッチし、続行する。ブロック2のピンを外す。ブロック3をピンしようとすると、バッファが利用可能になったため成功する。

```java
public class BufferMgrTest {
  public static void main(String[] args) throws Exception {
    SimpleDB db = new SimpleDB("buffermgrtest", 400, 3);
    BufferMgr bm = db.bufferMgr();

    Buffer[] buff = new Buffer[6];
    buff[0] = bm.pin(new BlockId("testfile", 0));
    buff[1] = bm.pin(new BlockId("testfile", 1));
    buff[2] = bm.pin(new BlockId("testfile", 2));
    bm.unpin(buff[1]);
    buff[1] = null;
    buff[3] = bm.pin(new BlockId("testfile", 0));
    buff[4] = bm.pin(new BlockId("testfile", 1));
    System.out.println("Available buffers: " + bm.available());
    try {
      System.out.println("Attempting to pin block 3...");
      buff[5] = bm.pin(new BlockId("testfile", 3));
    } catch(BufferAbortException e) {
      System.out.println("Exception: No available buffers\n");
    }
    bm.unpin(buff[2]);
    buff[2] = null;
    buff[5] = bm.pin(new BlockId("testfile", 3)); // now this works

    System.out.println("Final Buffer Allocation:");
    for (int i=0; i<buff.length; i++) {
      Buffer b = buff[i];
      if (b != null)
        System.out.println("buff["+i+"] pinned to block " + b.block());
    }
  }
}

```

## 4.5.2 バッファマネージャの実装

以下には、`Buffer`クラスのコードが含まれている。`Buffer`オブジェクトは、そのページに関する4種類の情報を追跡する。

- ページに割り当てられたブロックへの参照。ブロックが割り当てられていない場合、値はnullである。
- ページがピンされた回数。ピンカウントは各ピンごとに増加し、各アンピンごとに減少する。
- ページが変更されたかを示す整数。値が1の場合、ページは変更されていません。それ以外の場合、整数は変更を行ったトランザクションを識別する。
- ログ情報。ページが変更された場合、バッファは最新のログレコードのLSNを保持する。LSNの値は決して負にならない。クライアントが負のLSNで`setModified`を呼び出すと、その更新のためのログレコードが生成されなかったことを示す。

```java
public class Buffer {
  private FileMgr fm;
  private LogMgr lm;
  private Page contents;
  private BlockId blk = null;
  private int pins = 0;
  private int txnum = -1;
  private int lsn = -1;

  public Buffer(FileMgr fm, LogMgr lm) {
    this.fm = fm;
    this.lm = lm;
    contents = new Page(fm.blockSize());
  }

  public Page contents() {
    return contents;
  }
  
  public BlockId block() {
    return blk;
  }
  public void setModified(int txnum, int lsn) {
    this.txnum = txnum;
    if (lsn>=0) this.lsn = lsn;
  }

  public boolean isPinned() {
    return pins > 0;
  }

  public int modifyingTx() {
      return txnum;
  }
  
  void assignToBlock(BlockId b) {
    flush();
    blk = b;
    fm.read(blk, contents);
    pins = 0;
  }

  void flush() {
    if (txnum >= 0) {
      lm.flush(lsn);
      fm.write(blk, contents);
      txnum = -1;
    } 
  }

  void pin() {
    pins++;
  }

  void unpin() {
    pins--;
  }
}
```

`flush`メソッドは、バッファの割り当てられたディスクブロックがそのページと同じ値を持つようにする。ページが変更されていない場合、メソッドは何も行わない。変更されている場合、メソッドはまず対応するログレコードがディスクにあることを確認するために`LogMgr.flush`を呼び出し、その後、ページをディスクに書き込む。

`assignToBlock`メソッドは、バッファをディスクブロックに関連付けられる。バッファはまずフラッシュされ、前のブロックへの変更が保存される。その後、バッファは指定されたブロックに関連付けられ、その内容がディスクから読み込まれる。

`BufferMgr`のコードは以下に示されている。`pin`メソッドは指定されたブロックにバッファを割り当てる。これは、プライベートメソッド`tryToPin`を呼び出すことで行う。このメソッドには2つの部分がある。最初の部分である`findExistingBuffer`は、指定されたブロックにすでに割り当てられているバッファを見つけようとする。バッファが見つかれば返される。それ以外の場合、アルゴリズムの2番目の部分である`chooseUnpinnedBuffer`がナイーブ置換を使用してアンピンされたバッファを選択する。選択されたバッファの`assignToBlock`メソッドが呼び出され、既存のページが必要に応じてディスクに書き込まれ、新しいページがディスクから読み込まれる。アンピンされたバッファが見つからない場合、メソッドはnullを返す。
```java
public class BufferMgr {
  private Buffer[] bufferpool;
  private int numAvailable;
  private static final long MAX_TIME = 10000; // 10 seconds

  public BufferMgr(FileMgr fm, LogMgr lm, int numbuffs) {
    bufferpool = new Buffer[numbuffs];
    numAvailable = numbuffs;
    for (int i=0; i<numbuffs; i++) bufferpool[i] = new Buffer(fm, lm);
  }

  public synchronized int available() {
    return numAvailable;
  }

  public synchronized void flushAll(int txnum) {
    for (Buffer buff : bufferpool)
      if (buff.modifyingTx() == txnum) buff.flush();
  }

  public synchronized void unpin(Buffer buff) {
    buff.unpin();
    if (!buff.isPinned()) {
      numAvailable++;
      notifyAll();
    }
  }

  public synchronized Buffer pin(BlockId blk) {
    try {
      long timestamp = System.currentTimeMillis();
      Buffer buff = tryToPin(blk);
      while (buff == null && !waitingTooLong(timestamp)) {
          wait(MAX_TIME);
          buff = tryToPin(blk);
      }
      if (buff == null) throw new BufferAbortException();
      return buff;
    } catch(InterruptedException e) {
      throw new BufferAbortException();
    }
  }

  private boolean waitingTooLong(long starttime) {
    return System.currentTimeMillis() - starttime > MAX_TIME;
  }

  private Buffer tryToPin(BlockId blk) {
    Buffer buff = findExistingBuffer(blk);
    
    if (buff == null) {
      buff = chooseUnpinnedBuffer();
      if (buff == null) return null;
      buff.assignToBlock(blk);
    }

    if (!buff.isPinned()) numAvailable--;
    buff.pin();
    return buff;
   }

  private Buffer findExistingBuffer(BlockId blk) {
    for (Buffer buff : bufferpool) {
      BlockId b = buff.block();
      if (b != null && b.equals(blk)) return buff;
    }
    return null;
  }

  private Buffer chooseUnpinnedBuffer() {
    for (Buffer buff : bufferpool)
      if (!buff.isPinned()) return buff;
    return null;
  }
}
```

`tryToPin`がnullを返すと、`pin`メソッドはJavaの`wait`メソッドを呼び出す。Javaでは、すべてのオブジェクトに待機リストがある。オブジェクトの`wait`メソッドは、呼び出し元スレッドの実行を中断し、そのリストに配置する。図4.14では、スレッドは次の2つの条件のいずれかが発生するまで、そのリストにとどまる。

- 別のスレッドが`notifyAll`を呼び出す（これは`unpin`の呼び出しから発生する）。
- MAX_TIMEミリ秒が経過するのは、スレッドが待機しすぎていることを示す。

待機中のスレッドが再開されると、バッファを取得しようとしてそのループを続行する（他の待機中のすべてのスレッドと一緒に）。スレッドは、バッファを取得するか、タイムリミットを超えるまで、待機リストに戻され続ける。

`unpin`メソッドは指定されたバッファのピンを外し、そのバッファがまだピンされているかどうかを確認する。ピンされていない場合、`notifyAll`が呼び出されてすべてのクライアントスレッドが待機リストから削除される。これらのスレッドはバッファを争います。最初にスケジュールされたスレッドが勝つ。他のスレッドの1つがスケジュールされると、すべてのバッファがまだ割り当てられている場合、待機リストに戻される可能性がある。

## 4.6 章のまとめ

- データベースエンジンはディスクアクセスを最小限に抑えるよう努める必要がある。そのために、ディスクブロックを保持するために使用するメモリ内のページを注意深く管理する。これらのページを管理するデータベースコンポーネントは、ログマネージャーとバッファマネージャーである。
- ログマネージャーは、ログレコードをログファイルに保存する責任があります。ログレコードは常にログファイルに追加され、修正されることはないため、ログマネージャーは非常に効率的であることができる。ログマネージャーは単一のページを割り当てるだけで済み、そのページをディスクにできるだけ少ない回数で書き込むための単純なアルゴリズムを持っている。
- バッファマネージャーは、ユーザーデータを処理するために複数のページ、つまりバッファプールを割り当てる。バッファマネージャーは、クライアントの要求に応じて、バッファページをディスクブロックにピン留めおよびアンピンする。クライアントは、バッファがピン留めされた後にそのバッファのページにアクセスし、使用が終わったらバッファのピンを解除する。
- 変更されたバッファは、2つの場合にディスクに書き込まれる。ページが置換されているとき、およびリカバリマネージャーがディスク上にそれを必要とするときである。
- クライアントがブロックにページをピン留めするよう要求するとき、バッファマネージャーは適切なバッファを選択する。そのブロックのページがすでにバッファにある場合、そのバッファが使用される。それ以外の場合、バッファマネージャーは既存のバッファの内容を置換する。
- バッファを置換するアルゴリズムをバッファ置換戦略と呼ぶ。興味深い置換戦略には、次の4つがある：
  - Naïve：最初に見つかったアンピンされたバッファを選択する。
  - FIFO：内容が最も最近置換されたアンピンされたバッファを選択する。
  - LRU：最も最近アンピンされたバッファの内容を選択する。
  - Clock：最後に置換されたバッファから順にバッファを順次スキャンし、最初に見つかったアンピンされたバッファを選択する。
