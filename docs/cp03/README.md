# Cp03. Disk and File Management

データベースエンジンは、ディスクやフラッシュドライブなどの永続的な記憶装置にデータを保持する。この章では、これらの装置の特性を調査し、 RAID などの技術によってその速度と信頼性を向上させる方法を検討する。また、オペレーティングシステムがこれらの装置と対話するために提供する2つのインターフェース（ブロックレベルのインターフェースとファイルレベルのインターフェース）を調べ、データベースシステムに最も適したこれらの 2 つのインターフェースの組み合わせを提案する。最後に、SimpleDB ファイルマネージャを詳細に検討し、その API と実装について学ぶ。

## 目次

- [3.1 永続的データストレージ](#31-永続的データストレージ)
  - [3.1.1 ディスクドライブ](#311-ディスクドライブ)
  - [3.1.2 ディスクドライブへのアクセス](#312-ディスクドライブへのアクセス)
  - [3.1.3 ディスクアクセス時間の改善](#313-ディスクアクセス時間の改善)
    - [ディスクキャッシュ](#ディスクキャッシュ)
    - [シリンダー](#シリンダー)
    - [ディスクストライピング](#ディスクストライピング)
  - [3.1.4 ミラーリングによるディスクの信頼性向上](#314-ミラーリングによるディスクの信頼性向上)
  - [3.1.5 パリティによるディスクの信頼性向上](#315-パリティによるディスクの信頼性向上)
  - [3.1.6 RAID](#316-raid)
  - [3.1.7 フラッシュドライブ](#317-フラッシュドライブ)
- [3.2 ディスクへのブロックレベルインターフェース](#32-ディスクへのブロックレベルインターフェース)
- [3.3 ディスクへのファイルレベルインターフェース](#33-ディスクへのファイルレベルインターフェース)
  - [連続割り当て](#連続割り当て)
  - [エクステントベース割り当て](#エクステントベース割り当て)
- [3.4 データベースシステムとOS](#34-データベースシステムとos)
  - [ブロックレベルサポートの選択](#ブロックレベルサポートの選択)
  - [ファイルレベルインターフェースの使用](#ファイルレベルインターフェースの使用)
  - [妥協戦略](#妥協戦略)
- [3.5 SimpleDBのファイルマネージャ](#35-simpledbのファイルマネージャ)
  - [3.5.1 ファイルマネージャの使用](#351-ファイルマネージャの使用)
  - [3.5.2 ファイルマネージャの実装](#352-ファイルマネージャの実装)
    - [BlockIdクラス](#blockidクラス)
    - [Pageクラス](#pageクラス)
    - [FileMgrクラス](#filemgrクラス)
- [3.6 章のまとめ](#36-章のまとめ)


## 3.1 永続的データストレージ

データベースの内容は永続的に保持される必要があり、データベースシステムやコンピュータがダウンした場合でもデータが失われないようにしなければならない。このセクションでは、特に有用なハードウェア技術であるディスクドライブとフラッシュドライブについて検討する。フラッシュドライブはまだディスクドライブほど広く普及していないが、その技術が成熟するにつれて重要性が増すだろう。まずはディスクドライブから始める。

### 3.1.1 ディスクドライブ

ディスクドライブには 1 枚以上の回転するプラッタが含まれている。プラッタには同心円状のトラックがあり、各トラックはバイトの連続で構成されている。バイトは可動アームに取り付けられた読み書きヘッドによってプラッタから読み取られ（または書き込まれ）る。アームは目的のトラックに位置決めされ、ヘッドはその下を回転するバイトを読み取ったり書き込んだりする。図 3.1 は 1 枚プラッタのディスクドライブの上面の図を示している。当然ながら、この図は縮尺に基づいて描かれていない。というのも、典型的なプラッタには数千のトラックがあるからである。

現代のディスクドライブは通常、複数のプラッタを持っている。スペース効率を高めるために、プラッタの対は通常背中合わせに結合され、二面プラッタのように見えるが、概念的には各面が別々のプラッタである。各プラッタにはそれぞれ専用の読み書きヘッドがある。これらのヘッドは独立して動くことはなく、全てが単一のアクチュエータに接続されており、それにより全てのヘッドが同時に各プラッタの同じトラックに移動する。さらに、コンピュータへのデータパスが1つしかないため、一度にアクティブにできる読み書きヘッドは1つだけである。図 3.2 は多プラッタディスクドライブの側面図を示している。

ディスクドライブの一般的な性能は、容量、回転速度、転送速度、およびシークタイムの 4 つの値で測定できる。

ドライブの容量は、保存できるバイト数である。この値はプラッタの数、プラッタごとのトラック数、およびトラックごとのバイト数に依存する。プラッタはほぼ標準サイズで提供されるため、メーカーはプラッタの密度を高めること、つまりプラッタごとのトラック数やトラックごとのバイト数を増やすことによって容量を増加させる。40 GB以上のプラッタ容量は現在一般的である。

回転速度はプラッタの回転速度を示し、通常は毎分回転数（rpm）で表される。一般的な速度は 5400 rpm から 15,000 rpm である。

転送速度は、ディスクヘッドを通過するバイトがメモリに転送される速度である。例えば、1 回転の間に 1 トラック分のバイトが転送される場合がある。したがって、転送速度は回転速度とトラックごとのバイト数の両方によって決まる。100 MB/s の速度は一般的である。

シークタイムは、アクチュエータがディスクヘッドを現在の位置から要求されたトラックに移動するのにかかる時間である。この値は移動する必要のあるトラック数に依存する。同じトラックであれば 0 で済むし、プラッタの両端に位置している場合は 15〜20 ms になることもある。平均シークタイムはアクチュエータの速度を合理的に見積もるのに適している。現代のディスクの平均シークタイムは約 5 ms である。

次の例を考えてみる。4 プラッタのディスクドライブが 10,000 rpm で回転し、平均シークタイムが 5 ms であるとする。各プラッタには 10,000 トラックがあり、各トラックには 500,000 バイトが含まれている。ここにいくつかの計算値を示す：

| 指標           | 計算式                                                                   | 計算結果                               |
| -------------- | ------------------------------------------------------------------------ | -------------------------------------- |
| ドライブの容量 | 500,000 バイト/トラック × 10,000 トラック/プラッタ × 4 プラッタ/ドライブ | 20,000,000,000 バイト、つまり約 20 GB  |
| 転送速度       | 500,000 バイト/回転 × 10,000 回転/60秒                                   | 83,333,333 バイト/秒、つまり約 83 MB/s |

### 3.1.2 ディスクドライブへのアクセス

ディスクアクセスとは、ディスクドライブからメモリにバイトを読み込むか、メモリからディスクにバイトを書き込むリクエストのことである。これらのバイトは、プラッタ上のトラックの連続した部分に存在する必要がある。ディスクドライブは、ディスクアクセスを次の3つの段階で実行する：

- ディスクヘッドを指定されたトラックに移動する。この時間をシークタイムと呼ぶ。
- プラッタが回転して最初の必要なバイトがディスクヘッドの下に来るまで待つ。この時間を回転遅延と呼ぶ。
- プラッタが回転し続ける間、ディスクヘッドの下に現れる各バイトを読み取り（または書き込み）、最後の必要なバイトが現れるまで続ける。この時間を転送時間と呼ぶ。

ディスクアクセスを実行するのに必要な時間は、シークタイム、回転遅延、および転送時間の合計である。これらの時間はすべてディスクの機械的な動きに制約される。機械的な動きは電気的な動きよりもはるかに遅いため、ディスクドライブは RAM よりも非常に遅い。シークタイムと回転遅延は特に厄介である。これらの 2 つの時間はすべてのディスク操作にとって何の役にも立たないオーバーヘッドであり、すべてのディスク操作はこれを待たなければならない。

ディスクアクセスの正確なシークタイムと回転遅延を計算することは現実的ではない。なぜなら、ディスクの以前の状態を知る必要があるからである。代わりに、これらの時間を平均値で推定することができる。既に平均シークタイムについては知っている。平均回転遅延は簡単に計算できる。回転遅延は最小で 0（最初のバイトがちょうどヘッドの下にある場合）から最大で完全な回転の時間（最初のバイトがヘッドを通過したばかりの場合）になる。平均すると、プラッタが目的の位置に来るまでに 1/2 回転待つことになる。したがって、平均回転遅延は回転時間の半分である。

転送時間も転送速度から簡単に計算できる。特に、転送速度が r バイト/秒で、b バイトを転送する場合、転送時間は b/r 秒である。

例えば、10,000 rpm で回転し、平均シークタイムが 5 ms で、転送速度が 83 MB/s のディスクドライブを考えてみる。以下は計算されたコストである：

| 指標                            | 計算式                                                  | 計算結果                          |
| ------------------------------- | ------------------------------------------------------- | --------------------------------- |
| 平均回転遅延                    | 60 秒/分 × 1 分/ 10,000 回転 × 1/2 回転                 | 0.003 秒 または 3 ms              |
| 1 バイトの転送時間              | 1 バイト × 1 秒/ 83,000,000 バイト                      | 0.000000012 秒 または 0.000012 ms |
| 1000 バイトの転送時間           | 1,000 バイト × 1 秒/ 83,000,000 バイト                  | 0.000012 秒 または 0.012 ms       |
| 1 バイトへのアクセス推定時間    | 5 ms（シーク） + 3 ms（回転遅延） + 0.000012 ms（転送） | 8.000012 ms                       |
| 1000 バイトへのアクセス推定時間 | 5 ms（シーク） + 3 ms（回転遅延） + 0.012 ms（転送）    | 8.012 ms                          |

1000 バイトの推定アクセス時間が 1 バイトと実質的に同じであることに注意する。つまり、ディスクから数バイトをアクセスするのは無意味である。実際、仮にそうしたいとしても、現代のディスクは各トラックが固定長のセクターに分割されるように設計されているため、ディスクの読み取り（または書き込み）は一度に 1 セクター全体に対して行われる。セクターのサイズはディスクの製造元によって決定されるか、ディスクをフォーマットする際に選択されることがある。典型的なセクターサイズは 512 バイトである。

### 3.1.3 ディスクアクセス時間の改善

ディスクドライブは非常に遅いため、アクセス時間を改善するためのいくつかの技術が開発されている。このセクションでは、ディスクキャッシュ、シリンダー、およびディスクストライピングという3つの技術について考察する。

#### ディスクキャッシュ

ディスクキャッシュはディスクドライブに付属しているメモリで、通常は数千のセクターの内容を保存するのに十分な大きさである。ディスクドライブがディスクからセクターを読み取ると、そのセクターの内容をキャッシュに保存する。キャッシュがいっぱいの場合、新しいセクターが古いセクターを置き換える。セクターが要求されたとき、ディスクドライブはキャッシュをチェックする。セクターがキャッシュにある場合、実際のディスクアクセスなしに即座にコンピュータに返される。

アプリケーションが比較的短期間に同じセクターを複数回要求すると仮定する。最初の要求でセクターがキャッシュに入り、次の要求でキャッシュから取得されるため、ディスクアクセスが節約される。しかし、この機能はデータベースエンジンにはあまり役に立たない。なぜなら、データベースエンジンは独自のキャッシュを既に行っているからである（第 4 章で詳しく説明する）。セクターが複数回要求されると、エンジンはそのセクターを独自のキャッシュで見つけ、ディスクにアクセスすることさえない。

ディスクキャッシュの真の価値は、セクターを先読みする能力にある。要求されたセクターだけでなく、そのセクターを含むトラック全体をキャッシュに読み込むことで、後でそのトラックの他のセクターが要求されることを期待する。トラック全体を読み込むことは、単一のセクターを読み込むことよりもそれほど時間がかからない。特に、回転遅延が発生しない。なぜなら、ディスクは読み書きヘッドの下にあるセクターから読み始め、そのまま回転中に読み続けることができるからである。アクセス時間を比較してみる：

- セクターを読む時間 = シークタイム + 1/2 回転時間 + セクター回転時間
- トラックを読む時間 = シークタイム + 回転時間

つまり、単一のセクターを読むのとトラック全体を読むのとの差は、ディスクの回転時間の半分以下である。データベースエンジンがトラックの他のセクターを 1 つだけ要求した場合でも、トラック全体をキャッシュに読み込むことは時間の節約になる。

#### シリンダー

データベースシステムは、関連情報を近接するセクターに格納することでディスクアクセス時間を改善できる。例えば、ファイルを同じプラッタのトラックに配置するのが理想的である。この戦略は、ディスクがトラックベースのキャッシュを行っている場合に最適で、単一のディスクアクセスでファイル全体が読み込まれるからである。キャッシュがなくてもこの戦略は有効で、シークタイムを排除する。各セクターが読み込まれるたびに、ディスクヘッドは既に適切なトラックに位置している。

ファイルが複数のトラックにまたがる場合、その内容をプラッタの近くのトラックに格納することが良いアイデアである。そうすることで、トラック間のシークタイムが最小限に抑えられる。さらに良いアイデアは、その内容を他のプラッタの同じトラックに格納することである。各プラッタの読み書きヘッドは一緒に動くため、同じトラック番号を持つすべてのトラックに追加のシークタイムなしでアクセスできる。

同じトラック番号を持つトラックのセットをシリンダーと呼ぶ。ディスクの上からこれらのトラックを見ると、円筒の外側を描いているように見えるためである。実際には、シリンダーは非常に大きなトラックのように扱える。すべてのセクターに追加のシークなしでアクセスできるからである。

#### ディスクストライピング

ディスクアクセス時間を改善する別の方法は、複数のディスクドライブを使用することである。2 つの小さなドライブは、1 つの大きなドライブよりも速くなる。なぜなら、それらは 2 つの独立したアクチュエータを持ち、それぞれが同時に 2 つの異なるセクター要求に応答できるからである。例えば、2 つの 20 GB ディスクが連続的に動作すれば、1つの 40 GB ディスクの約 2 倍の速さになる。この速度向上はよくスケールする。一般に、N 個のディスクは単一のディスクの N 倍の速さになる。（もちろん、複数の小さなドライブは 1 つの大きなドライブよりも高価であるため、追加の効率性はコストがかかる。）

しかし、複数の小さなディスクの効率は、それらを忙しく保つことができないと失われる。例えば、1 つのディスクが頻繁に使用されるファイルを含み、他のディスクがあまり使用されないアーカイブファイルを含む場合、最初のディスクがすべての作業を行い、他のディスクはほとんどアイドル状態になる。この設定では、単一のディスクと同じくらいの効率しかない。

問題は、複数のディスク間でワークロードをどのように均等に分配するかである。データベース管理者がファイルの使用状況を分析し、各ディスクにファイルを最適に分配しようとすることが考えられるが、このアプローチは現実的ではない。これは難しい上に保証が難しく、継続的に再評価および修正する必要がある。幸いなことに、ディスクストライピングと呼ばれるはるかに良いアプローチがある。

ディスクストライピング戦略では、コントローラが小さなディスクをオペレーティングシステムから隠し、大きな単一のディスクの幻影を与える。コントローラは仮想ディスクのセクター要求を実際のディスクのセクター要求にマッピングする。マッピングは次のように機能する。N 個の小さなディスクがあり、それぞれ k セクターを持つとする。仮想ディスクは N×k セクターを持つ。これらのセクターは実際のディスクのセクターに交互に割り当てられる。ディスク 0 は仮想セクター 0、N、2N などを含む。ディスク 1 は仮想セクター 1、N+1、2N+1 などを含む。このようにして、ディスクストライピングという用語が生まれた。各小さなディスクが異なる色で塗られていると想像すると、仮想ディスクは交互に色が塗られたストライプのように見える。図 3.3を参照されたい。

ディスクストライピングは、データベースを小さなディスクに均等に分配するため効果的である。ランダムなセクターの要求が到着すると、その要求は小さなディスクの1つに均等な確率で送られる。また、連続するセクターの複数の要求が到着すると、それらは異なるディスクに送られる。したがって、ディスクができるだけ均等に動作することが保証される。

### 3.1.4 ミラーリングによるディスクの信頼性向上

データベースのユーザーは、ディスク上のデータが安全に保たれ、失われたり破損したりしないことを期待している。しかし、ディスクドライブは完全に信頼できるわけではない。プラッタ上の磁気材料が劣化し、セクターが読み取れなくなることがある。また、ほこりや衝撃によって読み書きヘッドがプラッタに擦れて、影響を受けたセクターが損なわれることもある（ヘッドクラッシュ）。

ディスク故障を防ぐ最も明白な方法は、ディスクの内容のコピーを保持することである。例えば、毎晩ディスクのバックアップを行い、ディスクが故障したときに新しいディスクを購入し、バックアップをコピーする方法がある。この戦略の問題点は、ディスクがバックアップされた時点と故障した時点の間に行われたすべての変更が失われることである。この問題を回避する唯一の方法は、ディスクへのすべての変更を発生時に複製することである。つまり、2 つの同一のディスクバージョンを保持する必要がある。これらのバージョンは互いにミラーリングされていると言う。

ストライピングと同様に、2 つのミラーリングされたディスクを管理するためにはコントローラが必要である。データベースシステムがディスク読み取りを要求すると、コントローラはどちらのディスクからでも指定されたセクターにアクセスできる。ディスク書き込みが要求されると、コントローラは両方のディスクに同じ書き込みを行う。理論的には、これらの 2 つのディスク書き込みは並行して実行でき、追加の時間を必要としない。しかし実際には、システムクラッシュに備えてミラーを順番に書き込むことが重要である。問題は、ディスク書き込みの途中でシステムがクラッシュすると、そのセクターの内容が失われることである。ミラーが並行して書き込まれると、セクターの両方のコピーが失われる可能性があるが、ミラーを順番に書き込むと、少なくとも 1 つのミラーは無傷で残る。

ミラーリングされたディスクの一方が故障した場合、データベース管理者は次の手順でシステムを復旧できる：

1. システムをシャットダウンする。
2. 故障したディスクを新しいディスクに交換する。
3. 正常なディスクから新しいディスクにデータをコピーする。
4. システムを再起動する。

残念ながら、この手順も完全ではない。新しいディスクへのコピー中に正常なディスクが故障すると、データが失われる可能性がある。両方のディスクが数時間以内に故障する確率は小さいが（今日のディスクでは約 1/60,000 である）、重要なデータベースであれば、この小さなリスクも許容できないかもしれない。このリスクを減らすために、2 つの代わりに 3 つのミラーリングされたディスクを使用できる。この場合、数時間以内に 3 つのディスクすべてが故障する可能性は非常に低く、無視できるほどの確率である。

ミラーリングはディスクストライピングと共存できる。一般的な戦略は、ストライピングされたディスクをミラーリングすることである。例えば、40 GB のデータを 4 つの 20 GB ドライブに保存する場合、2 つのドライブがストライピングされ、残りの 2 つがストライピングされたドライブのミラーになる。このような構成は高速かつ信頼性がある。図 3.4 を参照されたい。

### 3.1.5 パリティによるディスクの信頼性向上

ミラーリングの欠点は、同じ量のデータを保存するのにディスクが 2 倍必要になることである。この負担は特にディスクストライピングを使用する場合に顕著である。例えば、300 GB のデータを15 台の 20 GB ディスクに保存する場合、それらのミラーとしてさらに 15 台のディスクが必要になる。大規模なデータベースインストールでは、多くの小さなディスクをストライピングして巨大な仮想ディスクを作成することが一般的であるが、それと同数のディスクをミラー用に購入するのは魅力的ではない。多くのミラーディスクを使用せずに故障したディスクから復旧する方法があると良いだろう。

実際、他の任意の数のディスクをバックアップするために、1 台のディスクを使用する巧妙な方法がある。この戦略は、バックアップディスクにパリティ情報を保存することによって機能する。パリティは、以下のようにビットのセット S に対して定義される：

- S のパリティは、1 の数が奇数の場合は 1 である。
- S のパリティは、1 の数が偶数の場合は 0 である。
  
言い換えれば、パリティビットを S に追加すると、常に 1 の数が偶数になる。

パリティには次のような興味深く重要な特性がある：パリティを知っていれば、他のビットの値から任意のビットの値を決定することができる。例えば、S = {1, 0, 1} としよう。S のパリティは、1 の数が偶数であるため 0 である。最初のビットの値が失われたとする。パリティが 0 であるため、 セット{?, 0, 1} は偶数の 1 を持っている必要がある。したがって、欠けているビットは1であることが推測できる。同様の推論を他のビット（パリティビットを含む）に対しても行うことができる。

このパリティの使用法はディスクにも拡張される。N+1 台の同じサイズのディスクがあるとする。1 台のディスクをパリティディスクとして選び、残りの N 台のディスクにストライプデータを保存する。各ビットのパリティディスクは、他のすべてのディスクの対応するビットのパリティを求めることによって計算される。ディスクが 1 台故障した場合（パリティディスクを含む）、そのディスクの内容は他のディスクの内容をビットごとに確認することで再構築できる。図 3.5 を参照されたい。

ディスクはコントローラによって管理される。読み取りおよび書き込み要求は基本的にストライピングと同じ方法で処理される。コントローラは要求されたセクターを保持するディスクを特定し、その読み取り/書き込み操作を実行する。違いは、書き込み要求がパリティディスクの対応するセクターも更新する必要があることである。コントローラは、変更されたセクターのどのビットが変更されたかを確認して、更新されたパリティを計算できる。変更されたビットがある場合、対応するパリティビットも変更する必要がある。したがって、コントローラはセクターの書き込み操作を実行するために、セクターと対応するパリティセクターの両方を読み取り、新しい内容を書き込む必要がある。

このパリティ情報の使用には、ある種の「魔法」のような側面がある。つまり、1 台のディスクが他の任意の数のディスクを信頼性を持ってバックアップできるということである。しかし、この魔法には 2 つの欠点がある。

最初の欠点は、セクター書き込み操作がより時間がかかることである。2 つのディスクからの読み取りおよび書き込みが必要になるためである。経験上、パリティを使用すると、ストライピングの効率が約 20 % 低下することがわかっている。

パリティの2番目の欠点は、複数のディスクの同時故障に対してデータベースがより脆弱になることである。ディスクが 1 台故障すると、他のすべてのディスクが故障したディスクを再構築するために必要になり、どれか1台でも故障すると致命的である。データベースが多数の小さなディスク（例えば約 100 台）で構成されている場合、2 台目の故障の可能性は非常に現実的である。この状況は、ミラーリングの場合とは対照的である。ミラーリングでは、故障したディスクの復旧にはそのミラーが故障しないことだけが必要であり、この可能性ははるかに低いである。

### 3.1.6 RAID

前のセクションでは、複数のディスクを使用する 3 つの方法、すなわちディスクアクセス時間を高速化するためのストライピング、ディスク故障を防ぐためのミラーリングとパリティについて説明しました。これらの戦略は、コントローラを使用して複数のディスクの存在をオペレーティングシステムから隠し、単一の仮想ディスクのように見せかける。コントローラは、各仮想の読み取り/書き込み操作を基礎となるディスクへの 1 つまたは複数の操作にマップする。コントローラはソフトウェアまたはハードウェアで実装できるが、ハードウェアコントローラが一般的である。

これらの戦略は、RAID（Redundant Array of Inexpensive Disks、廉価なディスクの冗長アレイ）として知られる大規模な戦略コレクションの一部である。RAID には 7 つのレベルがある。

- RAID-0 はストライピングのみで、ディスク故障に対する保護はない。ストライプ化されたディスクの1つが故障すると、データベース全体が損傷する可能性がある。
- RAID-1 はミラーリングされたストライピングである。
- RAID-2 はセクターストライピングの代わりにビットストライピングを使用し、パリティの代わりにエラー訂正コードに基づく冗長性メカニズムを使用する。この戦略は実装が難しく、パフォーマンスが悪いため、現在は使用されていません。
- RAID-3 と RAID-4 はストライピングとパリティを使用する。RAID-3 はバイトストライピングを使用し、RAID-4 はセクターストライピングを使用する。一般に、セクターストライピングの方が効率的である。ディスクアクセスの単位に対応するためである。
- RAID-5 は RAID-4 に似ているが、パリティ情報を別のディスクに保存するのではなく、データディスクに分散して保存する。つまり、N 個のデータディスクがある場合、各ディスクの N 番目のセクタがパリティ情報を保持する。この戦略は RAID-4 よりも効率的である。単一のパリティディスクがボトルネックになることがないためである。
- RAID-6 は RAID-5 に似ているが、2 種類のパリティ情報を保持する。この戦略は 2 つの同時ディスク故障を処理できるため、追加のパリティ情報を保持するために別のディスクが必要である。

最も人気のある RAID レベルは RAID-1 と RAID-5 である。これらの選択は、基本的にはミラーリングとパリティの選択である。ミラーリングは、データベースインストールにおいて、速度と堅牢性から見てより堅固な選択となる傾向がある。また、追加のディスクドライブのコストが非常に低くなっているためでもある。

### 3.1.7 フラッシュドライブ

ディスクドライブは現在のデータベースシステムで一般的に使用されているが、克服できない欠点がある。それは、動作がスピンするプラッタと動くアクチュエータの機械的活動に完全に依存していることである。この欠点のために、ディスクドライブは電子メモリと比べて本質的に遅く、落下や振動、その他の衝撃による損傷を受けやすい。

フラッシュメモリは、ディスクドライブを置き換える可能性を持つ比較的新しい技術である。これは RAM に似た半導体技術を使用しているが、継続的な電源供給を必要としない。その動作が完全に電気的であるため、ディスクドライブよりもはるかに迅速にデータにアクセスでき、動く部品がないため損傷のリスクもない。

現在のフラッシュドライブのシークタイムは約 50 μs で、ディスクドライブの約 100 倍の速さである。現在のフラッシュドライブの転送速度は接続されているバスインターフェースに依存する。高速な内部バスで接続されたフラッシュドライブはディスクドライブと同等の速度を持っているが、外部の USB フラッシュドライブはディスクドライブよりも遅い。

フラッシュメモリには寿命がある。各バイトは一定の回数だけ書き換えることができ、その限界に達するとフラッシュドライブは故障する。現在、この最大値は数百万回であり、ほとんどのデータベースアプリケーションにとっては十分に高い。高級なドライブでは「ウェアレベリング」技術を使用して頻繁に書き込まれるバイトをあまり書き込まれていない場所に自動的に移動させる。この技術により、ドライブ全体のバイトが書き換え限界に達するまで動作を続けることができる。

フラッシュドライブはオペレーティングシステムに対してセクターベースのインターフェースを提供し、これによりフラッシュドライブはディスクドライブのように見える。フラッシュドライブでも RAID 技術を使用することが可能であるが、シークタイムが非常に低いため、ストライピングの重要性は低くなる。

フラッシュドライブの採用を妨げる主な障害はその価格である。現在の価格は同等のディスクドライブの約100倍である。フラッシュとディスク技術の価格はどちらも引き続き下がり続けるだろうが、最終的にはフラッシュドライブが主流として扱えるほど安くなるだろう。その時点で、ディスクドライブはアーカイブストレージや非常に大きなデータベースの保存に格下げされるかもしれない。

フラッシュメモリはディスクドライブのパフォーマンスを向上させるために、持続性のあるフロントエンドとしても使用できる。データベースが完全にフラッシュメモリに収まる場合、ディスクドライブは使用されなくなる。しかし、データベースが大きくなるにつれて、あまり頻繁に使用されないセクターはディスクに移行する。

データベースエンジンに関して言えば、フラッシュドライブはディスクドライブと同じ特性を持っている。それは持続性があり、遅く、セクター単位でアクセスされる。（ただし、ディスクドライブよりは遅くない。）したがって、本書では現在の用語に従って、持続性のあるメモリを「ディスク」と呼ぶ。

## 3.2 ディスクへのブロックレベルインターフェース

ディスクには異なるハードウェア特性がある。例えば、セクターサイズが異なる場合があり、セクターのアドレス指定方法も異なる場合がある。オペレーティングシステム（OS）はこれら（および他の）詳細を隠し、ディスクにアクセスするためのシンプルなインターフェースをアプリケーションに提供する。

このインターフェースの中心となる概念が「ブロック」である。ブロックはセクターに似ているが、そのサイズは OS によって決定される。各ブロックのサイズはすべてのディスクに対して同じ固定サイズである。OS はブロックとセクターの間のマッピングを維持する。また、OS はディスクの各ブロックにブロック番号を割り当てる。ブロック番号が与えられると、OS は実際のセクターアドレスを決定する。

ブロックの内容はディスクから直接アクセスすることはできない。その代わり、ブロックを構成するセクターをまずメモリページに読み込み、そこからアクセスする必要がある。ブロックの内容を変更するには、クライアントはブロックをページに読み込み、ページ内のバイトを変更し、そのページをディスク上のブロックに書き戻さなければなりません。

OS は通常、ディスクブロックにアクセスするためのいくつかのメソッドを提供する。例えば：

- readblock(n, p)：ディスクのブロック n のバイトをメモリのページ p に読み込む。
- writeblock(n, p)：メモリのページ p のバイトをディスクのブロック n に書き込む。
- allocate(k, n)：ディスク上の未使用の連続した k 個のブロックを見つけ、それらを使用中としてマークし、最初のブロック番号を返す。新しいブロックは可能な限りブロック n に近く配置される。
- deallocate(k, n)：ブロック n から始まる連続した k 個のブロックを未使用としてマークする。

OS はディスク上のブロックが使用可能かどうかを追跡する。これには、ディスクマップまたはフリーリストの 2 つの基本戦略がある。

ディスクマップは、ディスク上の各ブロックに 1 ビットを割り当てたビットのシーケンスである。ビット値が 1 の場合、そのブロックは未使用であり、0 の場合、そのブロックはすでに割り当てられている。ディスクマップは通常、ディスクの最初のいくつかのブロックに保存される。OS はブロック n を解放する際に、ディスクマップのビット n を 1 に変更するだけである。連続した k 個のブロックを割り当てるには、ディスクマップを検索して値 1 のビットが連続する k 個のブロックを見つけ、それらのビットを 0 に設定する。

フリーリストは、未割り当てのブロックの連続したシーケンスであるチャンクのチェーンである。各チャンクの最初のブロックには、チャンクの長さとチェーン上の次のチャンクのブロック番号の 2 つの値が保存される。ディスクの最初のブロックには、チェーン上の最初のチャンクへのポインタが含まれる。OS が連続した k 個のブロックを割り当てるように求められると、フリーリストを検索して十分に大きなチャンクを見つける。次に、OS はそのチャンク全体をフリーリストから削除して割り当てるか、長さkの部分を分割してそのブロックだけを割り当てることができる。チャンクのブロックを解放するように求められると、OS はそのチャンクをフリーリストに挿入する。

図 3.6 は、ブロック 0、1、3、4、8 および 9 が割り当てられているディスクに対するこれら 2 つの技術を示している。図 (a) は、ディスクのブロック 0 に保存されたディスクマップを示し、ビット値 0 は割り当てられたブロックを示す。図 (b) は対応するフリーリストを示している。ブロック 0 には、フリーリストの最初のチャンクがブロック 2 から始まることを示す値 2 が含まれている。ブロック 2 には、チャンクが 1 ブロックであり、次のチャンクがブロック 5 から始まることを示す 2 つの値 1 と 5 が含まれている。同様に、ブロック 5 の内容は、そのチャンクが 3 ブロック長であり、次のチャンクがブロック 10 にあることを示している。ブロック 10 の値 -1 は、それが最後のチャンクであり、残りのすべてのブロックを含むことを示している。

フリーリスト技術は、最小限の追加スペースしか必要としない。リストの最初のブロックを指す整数をブロック0に保存するだけで済む。一方、ディスクマップ技術にはマップを保持するためのスペースが必要である。図 3.6a では、マップが 1 つのブロックに収まると仮定しているが、一般的には複数のブロックが必要な場合もある。ディスクマップの利点は、ディスクの「穴」の位置を OS により良く把握させることができる点である。例えば、OS が一度に複数のブロックの割り当てをサポートする必要がある場合、ディスクマップが選ばれることがよくある。

## 3.3 ディスクへのファイルレベルインターフェース

OS は、ディスクへのより高レベルのインターフェースとしてファイルシステムを提供する。クライアントは、ファイルを名前付きのバイト列として認識する。このレベルではブロックの概念は存在せず、クライアントはファイル内の任意の位置から任意の数のバイトを読み書きできる。

Java クラスの RandomAccessFile は、ファイルシステムへの典型的な API を提供する。各 RandomAccessFile オブジェクトは、次の読み書き操作が行われるバイトを示すファイルポインタを持つ。このファイルポインタは seek メソッドで明示的に設定できる。メソッド readInt（または writeInt）の呼び出しは、読み込んだ（または書き込んだ）整数を越えてファイルポインタを移動させる。

以下のコードは、ファイル「junk」のバイト 7992〜7995 に保存されている整数をインクリメントする例である。readInt の呼び出しはバイト 7992 の整数を読み込み、そのファイルポインタをバイト 7996 に移動させる。続く seek の呼び出しはファイルポインタをバイト 7992 に戻し、その位置の整数を上書きできるようにする。

```java
RandomAccessFile f = new RandomAccessFile("junk", "rws");
f.seek(7992);
int n = f.readInt();
f.seek(7992);
f.writeInt(n+1);
f.close();
```

readInt や writeInt の呼び出しは、ディスクが直接アクセスされているかのように振る舞い、ディスクブロックがページを介してアクセスされなければならない事実を隠する。OS は通常、自分自身の使用のために複数のメモリページを予約しており、これらのページは I/O バッファと呼ばれる。ファイルが開かれると、OS はクライアントに知られることなくI/Oバッファをファイルに割り当てる。

ファイルレベルのインターフェースにより、ファイルをブロックのシーケンスとして考えることができる。例えば、ブロックが 4096 バイト（4K バイト）長の場合、バイト 7992 はファイルのブロック 1（つまり、2 番目のブロック）にある。「ファイルのブロック 1」のようなブロック参照は論理ブロック参照と呼ばれ、ファイルに対するブロックの位置を示するが、ディスク上のブロックの位置は示しない。

特定のファイル位置が与えられると、seek メソッドはその位置を保持する実際のディスクブロックを決定する。具体的には、seek は以下の 2 つの変換を行う。

- 指定されたバイト位置を論理ブロック参照に変換する。
- 論理ブロック参照を物理ブロック参照に変換する。

最初の変換は簡単である。論理ブロック番号はバイト位置をブロックサイズで割ったものである。例えば、4K バイトのブロックの場合、バイト 7992 はブロック 1 にある（7992/4096 = 1）。

2 つ目の変換はより難しく、ファイルシステムの実装方法に依存する。このセクションの残りでは、3 つのファイル実装戦略：連続割り当て、エクステントベース割り当て、およびインデックス割り当てについて考察する。これらの戦略のそれぞれは、ファイルシステムディレクトリにファイルの場所に関する情報をディスク上に保存する。seek メソッドは論理ブロック参照を物理ブロック参照に変換する際に、このディレクトリのブロックにアクセスする。これらのディスクアクセスは、ファイルシステムによって課される隠れた「オーバーヘッド」として考えることができる。OS はこのオーバーヘッドを最小限に抑えようとするが、完全に排除することはできない。

### 連続割り当て

連続割り当ては最も単純な戦略で、各ファイルを連続したブロックのシーケンスとして保存する。連続割り当てを実装するために、ファイルシステムディレクトリは各ファイルの長さと最初のブロックの位置を保持する。論理ブロック参照を物理ブロック参照にマッピングするのは簡単である。ファイルがディスクブロック b で始まる場合、ファイルのブロック N はディスクブロック b + N にある。図 3.8 は、ブロック 32 で始まる 48 ブロック長のファイル「junk」と、ブロック 80 で始まる 16 ブロック長のファイル「temp」を含むファイルシステムのディレクトリを示している。

連続割り当てには 2 つの問題がある。最初の問題は、すぐ後ろに別のファイルがある場合、ファイルを拡張できないことである。図 3.8 のファイル「junk」がその例である。したがって、クライアントは必要とする最大ブロック数でファイルを作成する必要があり、ファイルが完全でない場合にはスペースが無駄になる。この問題は内部フラグメンテーションとして知られている。2 つ目の問題は、ディスクがいっぱいになると、未割り当てブロックの小さなチャンクがたくさんあっても、大きなチャンクがないため、大きなファイルを作成できない可能性があることである。この問題は外部フラグメンテーションとして知られている。言い換えれば：

- 内部フラグメンテーションはファイル内部の無駄なスペースである。
- 外部フラグメンテーションはすべてのファイルの外部にある無駄なスペースである。

### エクステントベース割り当て

エクステントベース割り当て戦略は、連続割り当てのバリエーションであり、内部および外部フラグメンテーションの両方を減少させる。ここでは、OS はファイルを固定長エクステントのシーケンスとして保存し、各エクステントは連続したブロックのチャンクである。ファイルは 1 エクステントずつ拡張される。この戦略のファイルシステムディレクトリには、各ファイルのエクステントの最初のブロックのリストが含まれている。

例えば、OS がファイルを8ブロックのエクステントで保存するとする。図 3.9 は、以前と同じサイズの「junk」と「temp」の 2 つのファイルのファイルシステムディレクトリを示しているが、これらのファイルはエクステントに分割されている。ファイル「junk」には 6 つのエクステントがあり、ファイル「temp」には 2 つのエクステントがある。

ファイルのブロック N を保持するディスクブロックを見つけるには、seek メソッドがファイルシステムディレクトリでそのファイルのエクステントリストを検索し、そのエクステントリストを検索してブロック N を含むエクステントを特定し、そのエクステントからブロックの位置を計算する。例えば、図 3.9 のファイルディレクトリを考えてみましょう。ファイル「junk」のブロック 21 の位置は次のように計算できる：

1. ブロック 21 はファイルのエクステント 2 にある（21/8 = 2）。
2. エクステント 2 はファイルの論理ブロック 16（2×8 = 16）で始まる。
3. したがって、ブロック 21 はそのエクステントのブロック 5（21-16 = 5）にある。
4. ファイルのエクステントリストは、エクステント 2 が物理ブロック 696 で始まることを示している。
5. したがって、ブロック 21 の位置は 696 + 5 = 701 である。

## 3.4 データベースシステムとOS

OS はディスクアクセスのために 2 つのレベルのサポートを提供する：ブロックレベルサポートとファイルレベルサポートである。データベースエンジンの実装者はどちらのレベルを選ぶべきだろうか？

### ブロックレベルサポートの選択

ブロックレベルサポートを選択する利点には、どのディスクブロックをどの目的に使用するかについて、エンジンが完全な制御を持てる点がある。例えば、頻繁に使用されるブロックをシーク時間が少ないディスクの中央に配置することができる。同様に、よく一緒にアクセスされるブロックを近くに配置することができる。また、データベースエンジンはOS のファイルに関する制約を受けないため、OS の制限を超える大きさのテーブルや、複数のディスクドライブにまたがるテーブルをサポートすることが可能である。

しかし、ブロックレベルインターフェースを使用することにはいくつかのデメリットもある。この戦略は実装が複雑であり、ディスクをフォーマットし、未使用ディスクとしてマウントする必要がある。つまり、ブロックがファイルシステムの一部ではないディスクである。また、システムを微調整するためには、データベース管理者がブロックアクセスパターンについて広範な知識を持っている必要がある。

### ファイルレベルインターフェースの使用

もう一つの極端な選択肢としては、データベースエンジンが可能な限り OS ファイルシステムを利用する方法がある。例えば、各テーブルを個別のファイルに保存し、ファイルレベルの操作を使用してレコードにアクセスすることである。この戦略は実装が非常に容易であり、OS が実際のディスクアクセスをデータベースシステムから隠してくれる。

しかし、この方法は以下の 2 つの理由で受け入れがたい。まず、データベースシステムはブロックの境界を知る必要があり、効率的にデータを整理し取得するためである。次に、データベースシステムは独自のページを管理する必要がある。なぜなら、OS の I/O バッファ管理方法はデータベースクエリには不適切だからである。これらの問題は後の章で詳しく説明される。

### 妥協戦略

妥協策として、多くのデータベースシステムは、全データを 1 つまたは複数の OS ファイルに保存し、それらのファイルを未使用ディスクとして扱う。つまり、データベースシステムは「ディスク」に論理ファイルブロックを使用してアクセスする。OS は seek メソッドを通じて各論理ブロック参照を対応する物理ブロックにマッピングする。seek がファイルシステムディレクトリを調べる際にディスクアクセスを伴う可能性があるため、データベースシステムがディスクを完全に制御することはできない。しかし、これらの追加ブロックは通常、データベースシステムがアクセスする大量のブロックと比較して無視できる程度である。このようにして、データベースシステムは OS の高レベルインターフェースを使用しつつ、ディスクアクセスに対するかなりの制御を維持することができる。

この妥協戦略は多くのデータベースシステムで使用されている。例えば、Microsoft Access はすべてを単一の.mdbファイルに保持し、Oracle、Derby、SimpleDB は複数のファイルを使用する。

## 3.5 SimpleDB のファイルマネージャ

データベースエンジンのうち、オペレーティングシステムと対話する部分をファイルマネージャと呼ぶ。このセクションでは、SimpleDB のファイルマネージャについて説明する。3.5.1 節では、クライアントがファイルマネージャをどのように使用するかを、3.5.2 節では、その実装について説明する。

### 3.5.1 ファイルマネージャの使用

SimpleDB のデータベースは複数のファイルに保存される。各テーブルや各インデックスにはファイルがあり、ログファイルや複数のカタログファイルも存在する。SimpleDB のファイルマネージャは、これらのファイルへのブロックレベルアクセスを提供し、simpledb.file パッケージを介して利用される。このパッケージには3つのクラス：BlockId、Page、FileMgr が公開されている。その API は以下に示されている。

```java
// BlockId
public BlockId(String filename, int blknum);
public String filename();
public int    number();

// Page
public Page(int blocksize);
public Page(byte[] b);
public int    getInt(int offset);
public byte[] getBytes(int offset);
public String getString(int offset);
public void   setInt(int offset, int val);
public void   setBytes(int offset, byte[] val);
public void   setString(int offset, String val);
public int    maxLength(int strlen);

// FileMgr
public FileMgr(String dbDirectory, int blocksize);
public void    read(BlockId blk, Page p);
public void    write(BlockId blk, Page p);
public BlockId append(string filename);
public boolean isNew();
public int     length(String filename);
public int     blockSize();
```

BlockId オブジェクトは、ファイル名と論理ブロック番号によって特定のブロックを識別する。例えば、以下のコードは、ファイル student.tbl のブロック 23 を参照するオブジェクトを作成する。filename および number メソッドは、そのファイル名とブロック番号を返す。

```java
BlockId blk = new BlockId("student.tbl", 23);
```

Page オブジェクトは、ディスクブロックの内容を保持する。その最初のコンストラクタは、OS の I/O バッファからメモリを取得するページを作成し、このコンストラクタはバッファマネージャによって使用される。第二のコンストラクタは、Java の配列からメモリを取得するページを作成し、このコンストラクタは主にログマネージャによって使用される。様々な get および set メソッドを使用して、クライアントはページの指定された位置に値を保存またはアクセスすることができる。ページは 3 つの値型：int、string、および「blob」（すなわち任意のバイト配列）を保持できる。必要に応じて追加の型のための対応するメソッドを追加することができる（演習 3.17 参照）。クライアントはページの任意のオフセットに値を保存できるが、どの値がどこに保存されているかを知る責任がある。間違ったオフセットから値を取得しようとすると、予測不可能な結果が生じる。

FileMgr クラスは、OS ファイルシステムとの実際のやり取りを処理する。そのコンストラクタは 2 つの引数を取りる：データベースの名前を示す文字列と、各ブロックのサイズを示す整数である。データベース名は、データベースのファイルを含むフォルダの名前として使用され、このフォルダはエンジンのカレントディレクトリにある。そのようなフォルダが存在しない場合は、新しいデータベース用にフォルダが作成される。この場合、isNew メソッドは true を返し、そうでない場合は false を返す。このメソッドは新しいデータベースの適切な初期化に必要である。

read メソッドは、指定されたブロックの内容を指定されたページに読み込む。write メソッドは、その逆の操作を行い、ページの内容を指定されたブロックに書き込む。length メソッドは、指定されたファイルのブロック数を返す。

エンジンには 1 つの FileMgr オブジェクトがあり、システム起動時に作成される。SimpleDB クラス（simpledb.server パッケージ内）は、このオブジェクトを作成し、その fileMgr メソッドは作成されたオブジェクトを返す。

以下のFileTest クラスは、これらのメソッドの使用例を示している。

```java
public class FileTest {
  public static void main(String[] args) throws IOException {
    SimpleDB db = new SimpleDB("filetest", 400, 8);
    FileMgr fm = db.fileMgr();

    BlockId blk = new BlockId("testfile", 2);
    Page p1 = new Page(fm.blockSize());
    int pos1 = 88;
    p1.setString(pos1, "abcdefghijklm");
    int size = Page.maxLength("abcdefghijklm".length());
    int pos2 = pos1 + size;
    p1.setInt(pos2, 345);
    fm.write(blk, p1);

    Page p2 = new Page(fm.blockSize());
    fm.read(blk, p2);
    System.out.println("offset " + pos2 + " contains " + p2.getInt(pos2));
    System.out.println("offset " + pos1 + " contains " + p2.getString(pos1));
  }
}
```

このコードは 3 つのセクションに分かれている。最初のセクションは SimpleDB オブジェクトを初期化する。3 つの引数は、エンジンが「studentdb」という名前のデータベースを使用し、400 バイトのブロックと 8 つのバッファを持つプールを使用するように指定する。400 バイトのブロックサイズは SimpleDB のデフォルトである。デモデータベースを簡単に作成できるように人工的に小さくしている。商用データベースシステムでは、この値は OS によって定義されたブロックサイズに設定される。一般的なブロックサイズは 4K バイトである。バッファプールについては第 4 章で説明する。

先程のコードの第二のセクションは、文字列「abcdefghijklm」をファイル「testfile」の 2 番目のブロックの位置 88 に書き込む。その後、maxLength メソッドを呼び出して文字列の最大長を確認し、文字列の後の位置を特定する。そして、その位置に整数 345 を書き込む。

第三のセクションは、このブロックを別のページに読み込み、そこから 2 つの値を抽出する。

### 3.5.2 ファイルマネージャの実装

このサブセクションでは、3つのファイルマネージャクラスの実装を調べる。

#### BlockIdクラス

BlockIdクラスのコードを以下にに示す。

```java
public class BlockId {
  private String filename;
  private int blknum;

  public BlockId(String filename, int blknum) {
    this.filename = filename;
    this.blknum = blknum;
  }

  public String fileName() {
    return filename;
  }

  public int number() {
    return blknum;
  }

  public boolean equals(Object obj) {
    BlockId blk = (BlockId) obj;
    return filename.equals(blk.filename) && blknum == blk.blknum;
  }

  public String toString() {
    return "[file " + filename + ", block " + blknum + "]";
  }

  public int hashCode() {
    return toString().hashCode();
  }
}
```

fileName および number メソッドの直感的な実装に加えて、このクラスは equals、hashCode および toString も実装している。

#### Pageクラス

Pageクラスを実装するためのコードを以下に示す。

```java
public class Page {
  private ByteBuffer bb;
  public static final Charset CHARSET = StandardCharsets.US_ASCII;

  // A constructor for creating data buffers
  public Page(int blocksize) {
    bb = ByteBuffer.allocateDirect(blocksize);
  }

  // A constructor for creating log pages
  public Page(byte[] b) {
    bb = ByteBuffer.wrap(b);
  }

  public int getInt(int offset) {
    return bb.getInt(offset);
  }

  public void setInt(int offset, int n) {
    bb.putInt(offset, n);
  }

  public byte[] getBytes(int offset) {
    bb.position(offset);
    int length = bb.getInt();
    byte[] b = new byte[length];
    bb.get(b);
    return b;
  }

  public void setBytes(int offset, byte[] b) {
    bb.position(offset);
    bb.putInt(b.length);
    bb.put(b);
  }

  public String getString(int offset) {
    byte[] b = getBytes(offset);
    return new String(b, CHARSET);
  }

  public void setString(int offset, String s) {
    byte[] b = s.getBytres(CHARSET);
    setBytes(offset, b);
  }

  public static int maxLength(int strlen) {
    float bytesPerChar = CHARSET.newEncoder().maxBytesPerChar();
    return Integer.BYTES + (strlen * (int) bytesPerChar);
  }

  // a package private method, needed by FileMgr
  ByteBuffer contents() {
    bb.position(0);
    return bb;
  }
}

```

各ページは Java の ByteBuffer オブジェクトを使用して実装されている。ByteBuffer オブジェクトは、任意の位置に値を読み書きするメソッドを持つバイト配列をラップする。これらの値には、プリミティブな値（整数など）だけでなく、より小さいバイト配列も含まれる。たとえば、Page クラスの setInt メソッドは、ByteBuffer の putInt メソッドを呼び出してページに整数を保存する。Page の setBytes メソッドは、指定された blob を2つの値として保存する。最初に、指定された blob のバイト数、次にバイトそのものである。これらのメソッドは、整数を書き込むために ByteBuffer の putInt メソッドを呼び出し、バイトを書き込むために put メソッドを呼び出する。

ByteBuffer クラスには文字列を読み書きするメソッドがないため、Page は文字列値を blob として書き込むことを選択している。Java の String クラスには、文字列をバイト配列に変換する getBytes メソッドと、バイト配列を文字列に変換するコンストラクタがある。そのため、Page の setString メソッドは、文字列をバイトに変換するために getBytes を呼び出し、それらのバイトを blob として書き込む。同様に、Page の getString メソッドは、バイトバッファから blob を読み取り、それらのバイトを文字列に変換する。
文字列とそのバイト表現との変換は、文字エンコーディングによって決定される。ASCII や Unicode-16 など、いくつかの標準のエンコーディングが存在する。Java の Charset クラスには、これらのエンコーディングを実装したオブジェクトが含まれている。String のコンストラクタとその getBytes メソッドは、Charset 引数を受け取る。先程のコードでは Page が ASCII エンコーディングを使用していることがわかるが、お好みのエンコーディングを取得するために CHARSET 定数を変更できる。

文字エンコーディングによって、各文字がエンコードされるバイト数が決まりる。ASCII は 1 文字あたり 1 バイトを使用し、Unicode-16 は 1 文字あたり 2 バイトから 4 バイトを使用する。したがって、データベースエンジンは特定の文字列がどのくらいのバイト数にエンコードされるかを正確に知ることができない場合がある。Page の maxLength メソッドは、指定された文字数を持つ文字列の blob の最大サイズを計算する。これは、文字数を文字あたりの最大バイト数で乗算し、バイトと一緒に書かれる整数の 4 バイトを追加することで行われる。
ByteBuffer オブジェクトの基になるバイト配列は、Javaの配列またはオペレーティングシステムの I/O バッファから取得される可能性がある。Page クラスには、異なる種類の基になるバイト配列に対応する 2 つのコンストラクタがある。I/O バッファは貴重なリソースであるため、最初のコンストラクタの使用はバッファマネージャによって注意深く制御され、次の章で議論される。データベースエンジンの他のコンポーネント（ログマネージャなど）は、他のコンストラクタを使用する。

#### FileMgrクラス

FileMgr クラスのコードを以下に示す

```java
public class FileMgr {
  private File dbDirectroy;
  private int blocksize;
  private boolean isNew;
  private Map<String, RandamAccessFile> openFiles = new HashMap<>();

  public FileMgr(File dbDirectory, int blocksize) {
    this.dbDirectory = dbDirectory;
    this.blocksize = blocksize;
    isNew = !dbDirectory.exists();

    // create the directory if the database is new
    if (isNew)
      dbDirectory.mkdirs();

    // remove any leftover temporary tables
    for (String filename : dbDirectory.list())
      if (filename.startsWith("temp"))
        new File(dbDirectory, filename).delete();
  }

  public synchronized void read(BlockId blk, Page p) {
    try {
      RandomAccessFile f = getFile(blk.fileName());
      f.seek(blk.number() * blocksize);
      f.getChannel().read(p.contents());
    } catch (IOException e) {
      throw new RuntimeException("cannot read block" + blk);
    }
  }

  public synchronized void write(BlockId blk, Page p) {
    try {
      RandomAccessFile f = getFile(blk.fileName());
      f.seek(blk.number() * blocksize);
      f.getChannel().write(p.contents());
    } catch (IOException e) {
      throw new RuntimeException("cannot write block" + blk);
    }
  }

  public synchronized void append(String filename) {
    int newblknum = size(filename);
    BlockId blk = new BlockId(filename, newblknum);
    byte[] b = new byte[blocksize];
    try {
      RandomAccessFile f = getFile(blk.fileName());
      f.seek(blk.number() * blocksize);
      f.write(b);
    } catch (IOException e) {
      throw new RuntimeException("cannot append block" + blk);
    }
    return blk;
  }

  public int length(String filename) {
    try {
      RemoteAccessFile f = getFile(filename);
      return (int) (f.length() / blocksize);
    } catch (IOException e) {
      throw new RuntimeException("cannot access " + filename);
    }
  }

  public boolean isNew() {
    return isNew;
  }

  public int blockSize() {
    return blocksize;
  }

  private RandomAccessFile getFile(String filename) throws IOException {
    RandomAccessFile f = openFiles.get(filename);
    if (f == null) {
      File dbTable = new File(dbDirectory, filename);
      f = new RandomAccesFile(dbTable, "rws");
      openFiles.put(filename, f);
    }
    return f;
  }
}
```

このクラスの主な役割は、ページをディスクブロックに読み書きするメソッドを実装することである。read　メソッドは、指定されたファイル内の適切な位置にシークし、そのブロックの内容を指定されたページのバイトバッファに読み込む。write　メソッドも同様である。append　メソッドは、ファイルの末尾にシークし、そこに空のバイト配列を書き込む。これにより、OS　が自動的にファイルを拡張する。ファイルマネージャは常にファイルからブロックサイズのバイト数を読み書きし、常にブロックの境界で読み書きを行う。これにより、ファイルマネージャは、read, write　または append の各呼び出しで正確に 1 回のディスクアクセスが発生することを保証する。
マップ openFiles 内の各 RandomAccessFile オブジェクトは、オープンされているファイルに対応している。ファイルは「rws」モードで開かれていることに注意されたい。「rw」部分は、ファイルが読み書きのために開かれていることを指定している。「s」部分は、オペレーティングシステムがディスクパフォーマンスを最適化するためにディスク I/O を遅延させないことを指定している。その代わり、すべての書き込み操作は即座にディスクに書き込まれる必要がある。この機能により、データベースエンジンがディスクへの書き込みがいつ発生したかを正確に把握できるため、第 5 章のデータ復旧アルゴリズムを実装する際に特に重要である。

read, write および append メソッドは同期されており、つまり一度に 1 つのスレッドしかそれらを実行できない。メソッドが更新可能なオブジェクトを共有する場合、同期が必要である。たとえば、read が同期されていない場合、次のシナリオが発生する可能性がある。同じファイルから異なるブロックを読み取ろうとする 2 つの JDBC クライアントが、それぞれ独自のスレッドで実行されているとする。スレッド A が最初に実行される。read を実行し始めるが、f.seek を呼び出した直後に中断される。つまり、ファイルの位置は設定されているが、まだ読み取りは行われていない。次にスレッド B が実行され、read が完了する。スレッド A が再開されると、ファイルの位置が変更されているが、スレッドはそれに気付けない。そのため、誤って異なるブロックから読み取ることになる。

SimpleDB には 1 つの FileMgr オブジェクトしかない。これは、simpledb.server パッケージの SimpleDB コンストラクタによって作成される。FileMgr コンストラクタは、指定されたデータベースフォルダが存在するかどうかを確認し、必要に応じて作成する。コンストラクタは、第 13 章の物理演算子によって作成された可能性のある一時ファイルを削除する役割も担う。

## 3.6 章のまとめ

- ディスクドライブには 1 つ以上の回転プラッタが含まれている。プラッタには同心円のトラックがあり、各トラックはセクターで構成されている。セクターのサイズはディスクメーカーによって決定されるが、一般的なセクターサイズは 512 バイトである。
- 各プラッタには独自の読み取り/書き込みヘッドがある。これらのヘッドは独立して動作しない。代わりに、それらはすべて単一のアクチュエータに接続されており、それにより同時にそれぞれのプラッタの同じトラックに移動する。
- ディスクドライブは、ディスクアクセスを 3 つの段階で実行する:
  - アクチュエータは、ディスクヘッドを指定されたトラックに移動する。この時間をシーク時間と呼ぶ。
  - ドライブは、指定されたバイトがディスクヘッドの下にあるまでプラッタが回転するのを待つ。この時間を回転遅延と呼ぶ。ディスクヘッドの下を回転するバイトが読み取られる（または書き込まれる）。この時間を転送時間と呼ぶ。
- ディスクドライブは、そのアクティビティが機械的であるために遅い。ディスクキャッシュ、シリンダー、およびディスクストライピングを使用して、アクセス時間を改善できる。ディスクキャッシュは、トラック全体を一度に読み取ることでセクターを事前に取得できるようにする。シリンダーは、各プラッタの同じトラック番号を持つトラックの集まりである。同じシリンダー上のブロックは追加のシーク時間なしでアクセスできる。ディスクストライピングは、仮想ディスクの内容を複数の小さなディスクに分散する。小さなディスクが同時に動作できるため、スピードアップが発生する。
- RAID 技術を使用してディスクの信頼性を向上させることができる。基本的な RAID レベルは次のとおりである:
  - RAID-0 はストライピングで、追加の信頼性はない。ディスクが故障すると、データベース全体が効果的に破損する。
  - RAID-1 は、ストライピングにミラーリングを追加する。各ディスクには同じミラーディスクがある。ディスクが故障した場合、そのミラーを使用して再構築できる。
  - RAID-4 は、冗長なパリティ情報を保持する追加のディスクを使用してストライピングを行う。ディスクが故障した場合、その内容は他のディスク上の情報とパリティディスクと組み合わせることで再構築できる。
- RAID 技術では、複数のディスクの存在をオペレーティングシステムから隠し、単一の仮想ディスクの幻想を提供するためにコントローラが必要である。コントローラは、各仮想の読み書き操作を基礎となるディスク上での1つ以上の操作にマップする。
- ディスク技術はフラッシュメモリによって挑戦されている。フラッシュメモリは永続的であるが、ディスクよりも速い。なぜなら、完全に電子的であるからである。ただし、フラッシュはまだ RAM よりもかなり遅いため、オペレーティングシステムはフラッシュドライブをディスクドライブと同じように扱う。
- オペレーティングシステムは、ディスクおよびフラッシュドライブの物理的な詳細を、ブロックベースのインターフェースを提供することでクライアントから隠す。ブロックはセクターに似ているが、そのサイズは OS で定義されている。クライアントはブロック番号でデバイスの内容にアクセスする。オペレーティングシステムは、ディスク上のどのブロックが割り当て可能かをディスクマップまたはフリーリストを使用して追跡する。
- ページはメモリのブロックサイズの領域である。クライアントは、ブロックの内容をページに読み込んで、ページを変更し、そのページをブロックに書き戻すことでブロックを変更する。
- オペレーティングシステムはまた、ディスクへのファイルレベルのインターフェースも提供する。クライアントはファイルを名前付きのバイトのシーケンスとして見る。
- オペレーティングシステムは、連続割り当て、範囲ベースの割り当て、または索引付き割り当てを使用してファイルを実装できる。連続割り当ては、連続するブロックのシーケンスとして各ファイルを保存する。範囲ベースの割り当ては、各範囲が連続するブロックの塊であるファイルのシーケンスとして保存する。索引付きの割り当ては、ファイルの各ブロックを個別に割り当てる。各ファイルには、そのファイルに割り当てられたディスクブロックを追跡するための特別なインデックスブロックが保持される。
- データベースシステムは、ブロックレベルまたはファイルレベルのインターフェースのいずれかをディスクに使用することができる。良い妥協策は、データをファイルに保存するが、ファイルをブロックレベルでアクセスすることである。
